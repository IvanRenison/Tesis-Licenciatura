\documentclass{amsbook} % [fleqn] hace que las ecuaciones con \[  \] estÃ©n a la izquierda

\usepackage{polyglossia}
\setdefaultlanguage{spanish}

\usepackage{amsthm}
\usepackage{fontspec}
\usepackage{enumitem}
\usepackage[bookmarks]{hyperref}
\defaultfontfeatures{Renderer=Basic,Ligatures={TeX}}
\usepackage[math-style=ISO,bold-style=ISO]{unicode-math}
\setmathfont{Asana Math}
\usepackage{witharrows}
\WithArrowsOptions{fleqn,displaystyle,i,tikz={font={\small\normalfont}},ygap=0.5em,wrap-lines}

\hfuzz=50pt % Elimina warnings de "Overfull \hbox"

\usepackage[margin=5mm]{geometry} % Adjust the margin values as desired

\usepackage{float}
\usepackage[ruled, vlined, linesnumbered]{algorithm2e}
\SetKw{Break}{break}
\SetKwFor{Loop}{loop}{}{end loop}

\usepackage{listings} % Me gustarÃ­a hacer que use un syntax highlighting bonito (el por defecto es solo normal/negrita)
\lstset{basicstyle=\ttfamily} % Cambia la fuente a monospace y ajusta el tamaÃ±o de la fuente

\usepackage[capitalise]{cleveref}

\setlist[enumerate,1]{label={\em{(\arabic*)}}}

\newtheoremstyle{customstyle} % <name>
{} % <Space above>
{} % <Space below>
{\slshape} % <Body font> % Preguntar que opinan, y porque hay un warning
{1.5em} % <Indent amount>
{\bfseries} % <Theorem head font>
{.} % <Punctuation after theorem head>
{.5em} % <Space after theorem head>
{} % <Theorem head spec (can be left empty, meaning `normal`)

\theoremstyle{customstyle}
\newtheorem{definition}{DefiniciÃ³n}[chapter]
\newtheorem{theorem}{Teorema}[chapter]
\newtheorem{lemma}{Lema:}[chapter]
\addto\captionsspanish{\renewcommand{\proofname}{DemostraciÃ³n}}
\renewenvironment{proof}[1][\proofname]{{\bfseries #1: }}{\qed} % Cambiar estilo del tÃ­tulo de la demostraciÃ³n

\newtheoremstyle{factstyle} % <name>
{} % <Space above>
{} % <Space below>
{\normalfont} % <Body font> % Preguntar que opinan, y porque hay un warning
{1.5em} % <Indent amount>
{\bfseries} % <Theorem head font>
{.} % <Punctuation after theorem head>
{.5em} % <Space after theorem head>
{} % <Theorem head spec (can be left empty, meaning `normal`)

\theoremstyle{factstyle}
\newtheorem{fact}{AfirmaciÃ³n}[theorem]



\DeclareMathOperator{\sop}{sop}
\DeclareMathOperator{\lm}{lm}
\DeclareMathOperator{\lc}{lc}
\DeclareMathOperator{\lt}{lt}
\DeclareMathOperator{\tail}{tail}
\DeclareMathOperator{\amb}{amb}
\renewcommand{\S}{\text{S}}
\DeclareMathOperator{\B}{B}


\begin{document}
\fontsize{16pt}{19pt}\selectfont % Increase the font size

\chapter{IntroducciÃ³n informal}

En esta secciÃ³n se explica informalmente mas o menos de que se trata el tema de la tesis.

Usted posiblemente haya escuchado hablar de los polinomios de varias variables, esos como $5  + 3 y - 2 x y + x^3 y^5$ y que todo el conjunto de los polinomios con, por ejemplo, variables $x, y$ sobre un cuerpo $K$ se denota como $K[x, y]$.

En esos polinomios es producto entre las variables conmuta, asÃ­ que es lo mismo el polinomio $x y$ que el polinomio $y x$. Se puede considerar que eso no pasa, que el producto de las variables no conmuta, asÃ­ que $x y â‰  y x$, (pero que el producto de las variables con los coeficientes si conmuta, asÃ­ que por ejemplo $x 3 y = 3 x y$). Al hacer eso se obtiene algo como los polinomios, pero en el que los monomios son palabras. A esos polinomios se los llama polinomios no conmutativos y, por ejemplo, para las variables $x, y$ con coeficientes en un cuerpo $K$ se denota como $KâŸ¨x, yâŸ©$ y en general si $X$ es un alfabeto, $KâŸ¨XâŸ©$ es el conjunto de los polinomios no conmutativos sobre $X$.

Una problema de decisiÃ³n que existe sobre los polinomios no conmutativos es, dado un conjunto $G$ de polinomios no conmutativos y un polinomio no conmutativo $f$ es decidir si $f$ se pude escribir como combinaciÃ³n lineal lineal de elementos de $G$ con coeficientes en $KâŸ¨XâŸ©$, o escrito formalmente determinar si:

\[ âˆƒn âˆˆ â„•, g_1, â€¦, g_n âˆˆ F, f_1, â€¦, f_n, f'_1, â€¦, f'_n âˆˆ KâŸ¨XâŸ© : f = âˆ‘_{i = 1}^n f_i g_i f'_i \]

Este problema en el caso general no es computable, pero si se puede hacer un algoritmo que si es verdadero termina y si no puede no terminar, o hacer un algoritmo que intenta determinarlo y puede devolver que si, que no, o que no sabe pero podrÃ­a llegar a averiguarlo si sigue computando (asÃ­ como podrÃ­a no averiguarlo nunca).

Para se considera el conjunto $(G)$ de todos los polinomios no conmutativos que satisfacen ese $âˆƒ$ y se calcula algo que se llama una base de GrÃ¶bner de $(G)$, la cual puede ser finita o infinita computacionalmente enumerable y son estos Ãºltimos casos los que hacen que el problema no sea computable.

Para calcular esas bases de GrÃ¶bner hay dos algoritmos principales, llamados algoritmo de Buchberger y F4.

Antes de ahora ya hubo varias implementaciones de esos algoritmos, siendo la mas importante \texttt{operator\_gb} hecha por Clemens Hofstadler en python usando \texttt{sagemath} y que estÃ¡ explicada en â€¦ % Citar a Hof
junto con una explicaciÃ³n de toda la teorÃ­a (mucho mas en detalle que en esta tesis).

Como esa implementaciÃ³n estÃ¡ hecha en python y no corre en paralelo, el objetivo de esta tesis fue implementar en C++ esos algoritmos y hacerlos correr en paralelo.

\chapter{Definiciones preliminares}

En esta secciÃ³n se explican los conceptos matemÃ¡ticos necesarios para entender el resto del trabajo.
En particular se explica â€¦. % Completar

\section{Sistemas de re-escritura}

En esta sub-secciÃ³n se explican algunas definiciones y teoremas bÃ¡sicos de sistemas de re-escritura.

Para toda estÃ¡ secciÃ³n fijemos un conjunto $A$.

\begin{definition} Sean $â†’, âŸ¿ âŠ† A^2$ relaciones sobre $A$:
\begin{itemize}
\item $â†’ âˆ˜ âŸ¿ = \{(x, z) âˆˆ A^2 : âˆƒy âˆˆ A : x â†’ y âˆ§ y âŸ¿ z\}$
\item $â†’^0 = \{(x, x) : x âˆˆ A\}$
\item $â†’^{n + 1} = â†’^n âˆ˜ â†’$
\item $â†’^* = â‹ƒ_{n = 0}^âˆ â†’^n$
\item $â† = \{(y, x) âˆˆ A^2 : (x, y) âˆˆ â†’\}$
\item $â†” = â†’ âˆª â†$
\end{itemize}
\end{definition}

Para el resto de la secciÃ³n fijemos $â†’$ una relaciÃ³n sobre $A$.

\begin{definition}\

\begin{itemize}
\item $a$ estÃ¡ en forma normal $â‡” âˆ„x âˆˆ A : a â†’ x$
\item $b$ es forma normal de $a â‡” a â†’^* b âˆ§ b$ estÃ¡ en forma normal
\item $a$ tiene forma normal $â‡” âˆƒx âˆˆ A : x$ es forma normal de $a$
\item $a â†“ b â‡” âˆƒx âˆˆ A : a â†’^* x âˆ§ b â†’^* x$
\end{itemize}
\end{definition}

\begin{definition}\

\begin{itemize}
\item $â†’$ es confluente $â‡” âˆ€x, y, z âˆˆ A : x â†’^* y âˆ§ x â†’^*z â‡’ y â†“ z$
\item $â†’$ es Church-Rosser $â‡” âˆ€x, y âˆˆ A : x â†”ï¸^* y â‡” x â†“ y$
\item $â†’$ es normalizante $â‡” âˆ€x âˆˆ A : x$ tiene forma normal
\item $â†’$ es terminante $â‡” âˆ„X âˆˆ A^â„• : âˆ€i âˆˆ â„• : X_i â†’ X_{i + 1}$
\end{itemize}
\end{definition}

\begin{theorem}\label{thm:terminante â‡’ normalizante}
$â†’$ es terminante $â‡’Â â†’$ es normalizante
\end{theorem}

\begin{theorem}\label{thm:confluente â‡” Church-Rosser}
$â†’$ es confluente $â‡”Â â†’$ es Church-Rosser
\end{theorem}

\section{Ãlgebra libre}

Ahora si empezamos con el tema de la tesis en si.

\begin{definition}
Sea $X$ un alfabeto finito. Se define la estructura $(âŸ¨XâŸ©, Â·)$ de la siguiente manera:
\begin{itemize}
\item $âŸ¨XâŸ©$ son las palabras finitas sobre $X$
\item $Â· : âŸ¨XâŸ©^2 â†’ âŸ¨XâŸ©$ es la concatenaciÃ³n
\end{itemize}
A los elementos de $âŸ¨XâŸ©$ se los llama monomios libres sobre $X$, a $Â·$ el producto de $âŸ¨XâŸ©$ y a $(âŸ¨XâŸ©, Â·)$ el monoide libre sobre $X$.
\end{definition}

Por ejemplo, si $X = \{a, b, c\}$ algunos monomios son:

\begin{align*}
m_0 &= abbcb \\
m_1 &= bbc \\
m_2 &= bcb \\
m_3 &= Îµ \\
m_1 Â· m_2 &= bccbcb
\end{align*}

El $Îµ$ de $m_3$ es la palabra vacÃ­a. Notar que $m_1 â‰  m_2$ ya que el producto es no es conmutativo.

A partir de ahora fijamos $X$ un alfabeto finito.

\begin{definition}
Sean $v, w âˆˆ âŸ¨XâŸ©$:
\begin{itemize}
\item $v | w â‡” âˆƒa , b âˆˆ âŸ¨XâŸ© : w = avb$
\end{itemize}

Y cuando $v | w$ se dice que $v$ divide a $w$.
\end{definition}

Y en el ejemplo de antes tenemos por ejemplo $m_1 | m_0$ ya que $m_0 = a m_1 b$.

Mas adelante serÃ¡ necesario tener un orden entre los elementos de $âŸ¨XâŸ©$, pero no es necesario fijar uno concreto, asÃ­ que lo que vamos a hacer es definir las propiedades que tienen que tener un orden para servir y trabajar con un orden cualquiera que las cumpla.

\begin{definition}
Sea $â‰¤$ un orden total sobre $âŸ¨XâŸ©$, definimos que $â‰¤$ es un buen orden monomial si y solo si:
\begin{enumerate}
\item $âˆ€v, w, a, b âˆˆ âŸ¨XâŸ© : v â‰¤ w â‡’ avb â‰¤ awb$

\item $âˆ€S âŠ† âŸ¨XâŸ© : S â‰  âˆ… â‡’ S$ tiene mÃ­nimo elemento con respecto a $â‰¤$
\end{enumerate}
\end{definition}

Ahora un ejemplo de orden que cumple con esta definiciÃ³n:

\begin{definition}
Fijemos $X = \{x_1, â€¦, x_n\}$ y un orden total sobre $X$: $x_1 â‰¤ â€¦ â‰¤ x_n$, el cual se extiende (como es usual) de forma lexicogrÃ¡fica a $âŸ¨XâŸ©$. El orden lexicogrÃ¡fico por grado $ â‰¤_{deglex}$ sobre $âŸ¨XâŸ©$ se define asÃ­:
\[ a â‰¤_{deglex} b â‡” |a| < |b| âˆ¨ (|a| = |b| âˆ§ a â‰¤ b) \]
\end{definition}

O sea, el orden lexicogrÃ¡fico por grado es orden primero por cardinalidad, que se llama grado tambiÃ©n, y desempatar por orden lexicogrÃ¡fico, por ejemplo tenemos $bc â‰¤_{deglex} abb$, $aabbc â‰¤_{deglex} abbcc$ y $Îµ â‰¤_{deglex} a$.

Se puede probar fÃ¡cilmente que este orden es un bueno orden monomial.

A partir de ahora fijamos un buen orden monomial $â‰¤$, y usaremos $<$, $â‰¥$ y $>$ como se usan habitualmente.

Ahora una propiedad sobre el orden monomial que es consecuencia directa de la definiciÃ³n:

\begin{theorem}\label{thm:â‰¤ no cadenas dec inf}
La relaciÃ³n $â‰¤$ no tiene cadenas estrictamente decrecientes infinitas
\end{theorem}

Ahora pasamos a hablar de sumar monomios entre si para tener polinomios no conmutativos.

\begin{definition}[Ãlgebra libre (asociativa)]
Sea $R$ un anillo conmutativo. Se define $RâŸ¨XâŸ©$ la $R$-Ã¡lgebra libre sobre $X$ como:
\[ RâŸ¨XâŸ© = \{âˆ‘_{i = 1}^n c_i w_i : c_1, â€¦, c_n âˆˆ R, w_1, â€¦, w_n âˆˆ âŸ¨XâŸ©\} \]

La suma en $RâŸ¨XâŸ©$ se define de la manera esperable.

El producto por escalares de define como:
\[ c (âˆ‘_{i = 1}^n c_i w_i) = (âˆ‘_{i = 1}^n c c_i w_i) \]

El producto entre elementos de $RâŸ¨XâŸ©$ se define como:
\[ (âˆ‘_{i = 1}^n c_i w_i) Â· (âˆ‘_{i = 1}^m c'_i w'_i) = âˆ‘_{i = 1}^n âˆ‘_{j = 1}^m c_i c'_j w_i w'_j \]

A los elementos de $RâŸ¨XâŸ©$ se los llama polinomios no conmutativos.
% Esta definiciÃ³n creo que hay que mejorarla, pero no se como
\end{definition}

Algunos ejemplos de polinomios no conmutativos sobre $â„šâŸ¨\{a, b, c\}âŸ©$ son los siguientes:
\[ p_0 = a \]
\[ p_1 = ab + cb \]
\[ p_2 = 3 abb + 4 bcca - 2 acab \]

Notar que $p_1 â‰  ab + bc$ ya que el producto es no conmutativo.

Sobre los polinomios no conmutativos se hacen las siguientes definiciones:

\begin{definition}
Sean $R$ un anillo conmutativo, $p âˆˆ RâŸ¨XâŸ©$, $c_1, â€¦, c_n âˆˆ R$, $w_1, â€¦, w_n, w âˆˆ âŸ¨XâŸ©$, $f = âˆ‘_{i = 1}^n c_i w_i$ y $â‰¤$ un buen orden monomial.
\begin{itemize}
\item $f_w = \left\{\begin{array}{ll} w = w_i â†’ c_i \\ \text{si no} â†’ 0  \end{array} \right.$
\item $\sop(f) = \{w_1, â€¦, w_n\}$
\item $\lm_â‰¤(f) = \min_â‰¤(\sop(f))$
\item $\lc_â‰¤(f) = f_{\lm(f)}$
\item $\lt_â‰¤(f) = \lc_â‰¤(f) Â· \lm_â‰¤(f)$
\item $\tail_â‰¤(f) = f - \lt_â‰¤(f)$
\item $f$ es mÃ³nico $â‡” \lc_â‰¤(f) = 1$
\end{itemize}

A $\sop(f)$ se lo llama soporte de $f$, a $\lm_â‰¤(f)$ se lo llama monomio principal de $f$, a $\lc_â‰¤(f)$ se lo llama coeficiente principal de $f$ y a $\lt_â‰¤(f)$ se lo llama tÃ©rmino principal de $f$. Los nombres lm, lc, lt y tail vienen del inglÃ©s leading monomial, leading coefficient, leading term y tail respectivamente.

\end{definition}

\begin{theorem}
Sea $R$ un anillo conmutativo, entonces:
\[ (RâŸ¨XâŸ©, +, Â·)\text{ es un anillo} \]
\end{theorem}

Esto significa que aplican todas las definiciones y teoremas de anillo.
En particular vale la definiciÃ³n de ideal y algunas definiciones y teoremas relacionados, que como son muy importantes para este trabajo las repasaremos a continuaciÃ³n.

\begin{definition}\label{def:ideal}
Sean $R$ un anillo e $I, B âŠ† R$, definimos que $I$ es un ideal de $R$ si y solo si:
\begin{enumerate}
\item $I â‰  âˆ…$

\item $âˆ€a, b âˆˆ I : a + b âˆˆ I$

\item $âˆ€a âˆˆ I, r, r' âˆˆ R : r a r' âˆˆ I$
\end{enumerate}

\[ (B) = \{âˆ‘_{i = 1}^n c_i b_i c_i' : n âˆˆ â„•, b_1, â€¦, b_n âˆˆ B, c_1, â€¦, c_n, c_1', â€¦, c_n' âˆˆ R\} \]
\end{definition}

\begin{theorem}
Sean $R$ un anillo y $B âŠ† R$, entonces:
\[ (B)\text{ es un ideal de }R \]

\end{theorem}

AdemÃ¡s a $(B)$ se lo llama el ideal generado por $B$.

\begin{definition}[Congruencia modulo un ideal]\label{def:congruencia mod ideal}
Sean $R$ un anillo e $I âŠ† R$, se define $â‰¡_I$ como relaciÃ³n en $R$ asÃ­:
\[ a â‰¡_I b â‡” a - b âˆˆ I \]
\end{definition}

\begin{theorem}\label{thm:congruencia mod ideal es equivalencia}
Sean $R$ un anillo y $I âŠ† R$ un ideal, entonces:
\[ â‰¡_I \text{es una relaciÃ³n de equivalencia} \]
\end{theorem}

\begin{theorem}\label{thm:en ideal â‡” congruente 0}
Sean $R$ un anillo, $I âŠ† R$ un ideal y $a âˆˆ R$, entonces:
\[ a âˆˆ I â‡” a â‰¡_I 0 \]
\end{theorem}

Ahora volvemos al Ã¡lgebra libre y a partir de ahora fijamos un cuerpo $K$.

Una pregunta que surge es dado un conjunto finito $F âŠ† KâŸ¨XâŸ©$ y un elemento $f âˆˆ KâŸ¨XâŸ©$, Â¿se puede calcular si $f âˆˆ (F)$?

La respuesta a esa pregunta es que no, porque el problema es indecible. Sin embargo, si existen algoritmos que cuando $f âˆˆ (F)$ termina y devuelve una prueba, pero que cuando $f âˆ‰ (F)$ puede no terminar. Sobre esos algoritmos se trata este trabajo.

Mas adelante va a ser necesario comparar no solo monomios si no tambiÃ©n polinomios, asÃ­ que $â‰¤$ se extiende a $KâŸ¨XâŸ©$ asÃ­:

\begin{definition}
Sean $f, g âˆˆ  KâŸ¨XâŸ©$, definimos que $f < g$ si y solo si vale alguna de las siguientes:
\begin{enumerate}
\item $f = 0 âˆ§ g â‰  0$
\item $\lm_â‰¤(f) < \lm_â‰¤(g)$
\item $\lm(f) = \lm(g) âˆ§ \tail(f) < \tail(g)$
\end{enumerate}
Y $f â‰¤ g$ si y solo si $f < g âˆ¨ f = g$.
\end{definition}

Es decir, el orden en los polinomios es orden lexicogrÃ¡fico con el polinomio visto como una lista de monomios, sin coeficientes ordenada de mayor a menor.

Por ejemplo, tenemos estas desigualdades en $KâŸ¨XâŸ©$:
\[ a < ab \]
\[ bcc + c < bcc + abb \]
\[ ac < ac + aa \]

Ahora algunos teoremas sobre el orden de los polinomios.

\begin{theorem} La relaciÃ³n $<$ en $KâŸ¨XâŸ©$ es un pre-orden.
\end{theorem}

\begin{theorem}\label{thm:â‰¤ en KX no cadenas dec inf}
La relaciÃ³n $â‰¤$ en $KâŸ¨XâŸ©$ no tiene cadenas estrictamente decrecientes infinitas.
\end{theorem}
\begin{proof}
Supongamos que existen cadenas estrictamente decreciente infinita. Tomemos una $P$ que minimize $\lm(P_1)$. Tomar este mÃ­nimo es posible por el \cref{thm:â‰¤ no cadenas dec inf}

Notar que:

\begin{fact}\label{fact:â‰¤ en KX no cadenas dec inf:1} % Nombres de labels provisorios
$âˆ€i âˆˆ â„• : \lm(P_i) = \lm(P_1)$
\end{fact}
En efecto, no puede ser $\lm(P_i) < \lm(P_1)$ porque entonces $P_i, P_{i + 1}, â€¦$ serÃ­a una cadena estrictamente decreciente infinita que romperÃ­a la minimalidad de $\lm(P_1)$ y no puede ser $\lm(P_i) > \lm(P_1)$ porque $P$ es una cadena estrictamente decreciente.

\begin{fact}\label{fact:â‰¤ en KX no cadenas dec inf:2}
$\tail(P_1), \tail(P_2), â€¦$ es una cadena estrictamente decreciente infinita.
\end{fact}
Esto vale por aplicar la definiciÃ³n del orden polinomial, por la \cref{fact:â‰¤ en KX no cadenas dec inf:1} y por lo que estamos suponiendo sobre $P$.

Como claramente $0$ es un mÃ­nimo:

\begin{fact}\label{fact:â‰¤ en KX no cadenas dec inf:3}
$P_1 â‰  0$.
\end{fact}

Sin embargo, la \cref{fact:â‰¤ en KX no cadenas dec inf:2} contradice la minimalidad de $\lm(P_1)$ ya que por la \cref{fact:â‰¤ en KX no cadenas dec inf:3} vale que $\lm(\tail(P_1)) < \lm(P_1)$.

\end{proof}

\begin{definition}
Sean $F âŠ† KâŸ¨XâŸ©$, $g âˆˆ KâŸ¨XâŸ© - \{0\}$, $a, b âˆˆ âŸ¨XâŸ©$ y $f, f' âˆˆ KâŸ¨XâŸ©$:
\begin{itemize}
\item $f â†’_{â‰¤, a, g, b} f' â‡” \lm_â‰¤(agb) âˆˆ \sop(f) âˆ§ f' = f - \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb$
\item $â†’_{â‰¤, g} = â‹ƒ_{a, b âˆˆ âŸ¨XâŸ©} â†’_{â‰¤, a, g, b}$
\item $â†’_{â‰¤, F} = â‹ƒ_{g âˆˆ F} â†’_{â‰¤, g}$
\end{itemize}
\end{definition}

\begin{theorem}[Las reducciones achican]\label{thm:â†’ achican}
Sean $F âŠ† KâŸ¨XâŸ©$, $g âˆˆ KâŸ¨XâŸ© - \{0\}$, $a, b âˆˆ âŸ¨XâŸ©$ y $f, f' âˆˆ KâŸ¨XâŸ©$, entonces:
\begin{enumerate}
\item $f â†’_{â‰¤, a, g, b} f' â‡’ f' < f$

\item $f â†’_{â‰¤, g} f' â‡’ f' < f$

\item $f â†’_{â‰¤, F} f' â‡’ f' < f$
\end{enumerate}
\end{theorem}
\begin{proof}
Por definiciÃ³n de las reducciones tenemos que (1) $â‡’$ (2) $â‡’$ (3), por lo cual alcanza con probar (1). Para ello supongamos el antecedente $f â†’_{â‰¤, a, g, b} f'$

Esto implica por definiciÃ³n de reducciones:
\begin{enumerate}
\setcounter{enumi}{3}
\item $\lm_â‰¤(agb) âˆˆ \sop(f)$
\item $f' = f - \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb$
\end{enumerate}

Escribamos $f = âˆ‘_{i = 1}^n c_i m_i$ con $c_1, â€¦, c_n âˆˆ K$, $m_1, â€¦, m_n âˆˆ âŸ¨XâŸ©, m_1 > m_2 > â€¦ > m_n$

Sea $i$ tal que $m_i = \lm_â‰¤(agb)$, el cual existe por (4).

\begin{fact}\label{fact:â†’ achican:3}
Notar tambiÃ©n que $m_i = \lm_â‰¤(\frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb)$ porque es multiplicar por un escalar adentro del $\lm$ en la condiciÃ³n de $i$.
\end{fact}
\begin{description}
\item[Si $i â‰  0$] La \cref{fact:â†’ achican:3} significa que los tÃ©rminos $c_1 m_1, c_2 m_2, â€¦, c_{i-1}, m_{i-1}$ son iguales en $f$ y en $f'$ y no hay nada mas en el medio, porque $f'$ es $f$ con cosas menores o iguales a $\lm_â‰¤(\frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb)$ restadas (por (5)).

AdemÃ¡s, como $m_i = \lm_â‰¤(\frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb)$, tenemos que $f'_{m_i} = 0$, por ende, el tÃ©rmino que sigue despuÃ©s de $m_{i-1}$ (si es que hay) es menor que $m_i$ y por ende menor que $f$.

\item[Si $i = 0$] aplica lo mismo pero directamente a $m_0$ solo que sin tener en cuenta los $m$ anteriores.
\end{description}

\end{proof}

\begin{theorem}\label{thm:suma â†’â†“}
Sean $F âŠ† KâŸ¨XâŸ©, f, f_0, f_1 âˆˆ KâŸ¨XâŸ©$, entonces:
\[ f_0 â†’_{â‰¤, F} f_1 â‡’ f_0 + f â†“_{â‰¤, F} f_1 + f \]
\end{theorem}
\begin{proof}
Supongamos el antecedente $f_0 â†’_{â‰¤, F} f_1$.

Sean $g âˆˆ F, a, b âˆˆ KâŸ¨XâŸ©$ tales que $f_1 = f_0 - \frac{{f_0}_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb$, los cuales existen por el antecedente y por definiciÃ³n de $â†’_{â‰¤, F}$.

Dividamos en casos segÃºn si $\lm_â‰¤(agb) âˆˆ \sop(f)$:

\begin{description}
\item[Caso $\lm_â‰¤(agb) âˆ‰ \sop(f)$]\

En este caso tenemos $f_0 + f â†’_{â‰¤, F} f_1 + f$ por tomar $g$, $a$ y $b$, y por ende tenemos $f_0 + f â†“_{â‰¤, F} f_1 + f$

\item[Caso $\lm_â‰¤(agb) âˆˆ \sop(f)$]\
\begin{description}
\item[Subcaso $f_{\lm_â‰¤(agb)} = -{f_0}_{\lm_â‰¤(agb)}$]

Este es el caso en el que $\lm_â‰¤(agb)$ se cancela en la suma $f_0 + f$. Y como ademÃ¡s $\lm_â‰¤(agb) âˆ‰ \sop(f_1)$ por el antecedente, tenemos:

\begin{DispWithArrows*}
&f_1 + f â†’_{â‰¤, F} f_1 + f - \frac{f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \Arrow{Subcaso} \\
& â‡’ f_1 + f â†’_{â‰¤, F} f_1 + f + \frac{{f_0}_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \Arrow{CondiciÃ³n de $g$, $a$ y $b$} \\
& â‡’ f_1 + f â†’_{â‰¤, F} f_0 + f \\
& â‡’ f_1 + f â†“_{â‰¤, F} f_0 + f
\end{DispWithArrows*}

\item[Subcaso $f_{\lm_â‰¤(agb)} â‰  -{f_0}_{\lm_â‰¤(agb)}$] En este caso $\lm_â‰¤(agb)$ no se cancela en la suma $f_0 + f$, asÃ­ que podemos aplicar $â†’_{â‰¤, F}$:
\begin{DispWithArrows*}
&f_0 + f â†’_{â‰¤, F} f_0 + f - \frac{(f_0 + f)_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \\
& â‡’ f_0 + f â†’_{â‰¤, F} f_0 + f - \frac{{f_0}_{\lm_â‰¤(agb)} + f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \\
& â‡’ f_0 + f â†’_{â‰¤, F} f_0 + f - \frac{{f_0}_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb - \frac{f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \Arrow{CondiciÃ³n de $g$, $a$ y $b$}\\
& â‡’ f_0 + f â†’_{â‰¤, F} f_1 + f - \frac{f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb
\end{DispWithArrows*}
Â Â Llamemos (1) a este Ãºltimo resultado.

AdemÃ¡s por el caso y por subcaso tambiÃ©n tenemos $\lm_â‰¤(agb) âˆˆ \sop(f_1 + f)$, asÃ­ que tenemos:
\begin{DispWithArrows*}
&f_1 + f â†’_{â‰¤, F} f_1 + f - \frac{(f_1 + f)_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \\
& â‡’ f_1 + f â†’_{â‰¤, F} f_1 + f - \frac{{f_1}_{\lm_â‰¤(agb)} + f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \Arrow{$\lm_â‰¤(agb) âˆ‰ \sop(f_1)$ porque $f_0 â†’_{â‰¤, F} f_1$ y definiciÃ³n de $â†’_{â‰¤, F}$}\\
& â‡’ f_1 + f â†’_{â‰¤, F} f_1 + f - \frac{0 + f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb \\
& â‡’ f_1 + f â†’_{â‰¤, F} f_1 + f - \frac{f_{\lm_â‰¤(agb)}}{g_{\lm_â‰¤(agb)}} agb
\end{DispWithArrows*}
Â Â Llamemos (2) a este Ãºltimo resultado.

Por (1) y (2) tenemos $f_0 + f â†“_{â‰¤, F} f_1 + f$
\end{description}
\end{description}
\end{proof}

\begin{theorem}[Clausura reflexo transitiva de las reducciones]\label{thm:â†’^* = â‰¡}
Sea $F âŠ† KâŸ¨XâŸ©$, entonces:
\[ â†”^*_{â‰¤, F} = â‰¡_{(F)} \]

(Donde $â‰¡_{(F)}$ es la congruencia modulo un ideal definida en la \cref{def:congruencia mod ideal})
\end{theorem}
\begin{proof}
Lo vamos a probar por doble inclusiÃ³n
\begin{description}

\item[Prueba de $â†”^*_{â‰¤, F} âŠ† â‰¡_{(F)}$] Como tanto $â†”^*_{â‰¤, F}$ como $â‰¡_{(F)}$ son relaciones de equivalencia y ademÃ¡s $â†”^*_{â‰¤, F}$ es la mÃ­nima relaciÃ³n de equivalencia que contiene a $â†’_{â‰¤, F}$, alcanza con probar $â†’_{â‰¤, F} âŠ† â‰¡_{(F)}$. Para eso supongamos $f â†’_{â‰¤, F} f'$ y probemos $f â‰¡_{(F)} f'$.

Sean $g âˆˆ F, a, b âˆˆ âŸ¨XâŸ©$ tales que $f' = f - \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb$, los cuales existen por lo que estamos suponiendo y por la definiciÃ³n de $â†’_{â‰¤, F}$. Tenemos:

\begin{DispWithArrows*}
&f â‰¡_{(F)} f' \\
& â‡” f - f' âˆˆ (F) \\
& â‡” f - (f - \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb) âˆˆ (F) \\
& â‡” \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb âˆˆ (F)
\end{DispWithArrows*}
Y esto Ãºltimo es claramente cierto por la definiciÃ³n de ideal (\cref{def:ideal})

\item[Prueba de $â‰¡_{(F)} âŠ† â†”^*_{â‰¤, F}$] Supongamos $f â‰¡_{(F)} f'$ y probemos $f â†”^*_{â‰¤, F} f'$.

Sean:
\begin{itemize}
\item $g = f - f'$.
\item $c_1, â€¦, c_n, c_1', â€¦, c_n' âˆˆ KâŸ¨XâŸ©$, $g_1, â€¦, g_n âˆˆ F$ tales que $g = âˆ‘_{i = 1}^n c_i g_i c_i'$, los cuales existen porque por definiciÃ³n de $â‰¡_Â·$ tenemos $g âˆˆ (F)$ y por definiciÃ³n de $(\ Â·\ )$.
\item $f_0 = f$
\item Para cada $i âˆˆ \{1, â€¦, n\}$: $f_i = f_{i - 1} - c_i g_i c_i'$.
\end{itemize}

Tenemos entonces:

\begin{DispWithArrows*}
&âˆ€i âˆˆ \{1, â€¦, n\} : g_i â†’_{â‰¤, F} 0 \\
& â‡’ âˆ€i âˆˆ \{1, â€¦, n\} : - c_i g_i c_i' â†’_{â‰¤, F} 0 \Arrow{\cref{thm:suma â†’â†“}} \\
& â‡’ âˆ€i âˆˆ \{1, â€¦, n\} : f_{i - 1} â†“_{â‰¤, F} f_i \\
& â‡’ âˆ€i âˆˆ \{1, â€¦, n\} : f_{i - 1} â†”^*_{â‰¤, F} f_i \\
& â‡’ f_0 â†”^*_{â‰¤, F} f_n \Arrow{$f_n = f - g = f'$}\\
& â‡’ f â†”^*_{â‰¤, F} f_n
\end{DispWithArrows*}

\end{description}
\end{proof}

\begin{theorem}[Las reducciones se mantienen en ideal]\label{thm:â†’ mantiene pertenencia a ideal}
Sean $F âŠ† KâŸ¨XâŸ©, f, f' âˆˆ (F)$, entonces:
\[ f â†’^*_{â‰¤, F} f' â‡’ (f âˆˆ (F) â‡” f' âˆˆ (F)) \]
\end{theorem}
\begin{proof}
Si asumimos $f â†’^*_{â‰¤, F} f'$ tenemos por el \cref{thm:â†’^* = â‰¡} $f â‰¡_{(F)} f'$ y entonces por el \cref{thm:en ideal â‡” congruente 0} tenemos $f âˆˆ (F) â‡” f' âˆˆ (F)$
\end{proof}

\begin{theorem}
Sea $F âŠ† KâŸ¨XâŸ©$, entonces:
\begin{itemize}
\item $â†’_{â‰¤, F}$ es terminante
\end{itemize}
\end{theorem}
\begin{proof} Lo vamos a demostrar por contradicciÃ³n. Supongamos que $â†’_{â‰¤, F}$ no es terminante, por definiciÃ³n de terminante podemos tomar una cadena $P âˆˆ KâŸ¨XâŸ©^â„•$ tal que:

$âˆ€i âˆˆ â„• : P_i â†’_{â‰¤, F} P_{i+1}$

Por el \cref{thm:â†’ achican} tenemos que:

$âˆ€i âˆˆ â„• : P_i > P_{i+1}$

Pero esto contradice el \cref{thm:â‰¤ en KX no cadenas dec inf} que dice que no hoy cadenas estrictamente decrecientes infinitas en $KâŸ¨XâŸ©$.

\end{proof}

\begin{theorem}[CaracterizaciÃ³n de las formas normales de $â†’$]
Sea $F âŠ† KâŸ¨XâŸ©, f âˆˆ KâŸ¨XâŸ©$, entonces: % Por algÃºn motivo acÃ¡ se pone solo un salto de linea extra
\[ f\text{ estÃ¡ en forma normal con respecto a} â†’_{â‰¤, F} â‡” âˆ„g âˆˆ F, m âˆˆ \sop(f) : \lm(g) | m \]
\end{theorem}
\begin{proof}
Por contradicciÃ³n, supongamos que tenemos $g âˆˆ F, m âˆˆ \sop(f)$ tales que $\lm(g) âˆˆ \sop(f)$.

Sean $a, b âˆˆ âŸ¨XâŸ©$ tal que $m = agb$, los cuales existen por la definiciÃ³n de divisibilidad.

Entonces tenemos $f â†’_{â‰¤, F} f - \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb$ y por ende $f$ no estÃ¡ en forma normal.

\end{proof}

Sin embargo $â†’_{â‰¤, F}$ no necesariamente es confluente, eso motiva las siguientes dos definiciones.

\begin{definition}[Bases de GrÃ¶bner]\label{def:base de GrÃ¶bner}
Sean $I$ un ideal de $KâŸ¨XâŸ©$ y $F âŠ† KâŸ¨XâŸ©$:
\begin{itemize}
\item $F$ es una base de GrÃ¶bner de $I â‡” (F) = IÂ âˆ§ â†’_{â‰¤, F}$ es confluente
\item $F$ es una base de GrÃ¶bner reducida de $I â‡” F$ es una base de GrÃ¶bner de $IÂ âˆ§ âˆ€g âˆˆ F : g$ es irreducible con respecto a $â†’_{â‰¤, F - \{g\}}$
\end{itemize}
\end{definition}

\begin{definition}
Sea $e_â‰¤ : ğ’«(KâŸ¨XâŸ©) â†’ KâŸ¨XâŸ© â†’ KâŸ¨XâŸ©$:
\begin{itemize}
\item $e_â‰¤$ es una estrategia de reducciÃ³n $â‡” âˆ€F âŠ† KâŸ¨XâŸ©, f âˆˆ KâŸ¨XâŸ© : e_â‰¤(F)(f)$ es forma normal de $f$ con respecto a $â†’_{â‰¤, F}$
\end{itemize}
\end{definition}

En los casos en los que $F$ es una base de GrÃ¶bner y por ende $â†’_{â‰¤, F}$ es confluente hay una sola $e_â‰¤(F)$ posible, pero cuando no es confluente puede haber muchas. Tener definida la estrategia de reducciÃ³n como una funciÃ³n nos va a venir bien mas adelante para hablar de una forma normal manteniendo la generalidad de como se calcula una forma normal de cada elemento.

Un ejemplo de estrategia de reducciÃ³n podrÃ­a calcularse con el siguiente seudocÃ³digo:

\begin{algorithm}[H] % La H es para que se quede acÃ¡, porque se iba a otra pÃ¡gina. EstarÃ­a bueno hacerlo global
  \caption{Ejemplo de estrategia de reducciÃ³n}\label{alg:estrategia de reducciÃ³n}
  \KwData{$F = \{f_1, â€¦, f_n\} âŠ† KâŸ¨XâŸ©, g âˆˆ KâŸ¨XâŸ©$}
  \KwResult{$g' âˆˆ KâŸ¨XâŸ©$}
  $g' â† g$

  $i â† 1$

  \While{$i â‰¤ n$} {
    \While{$i â‰¤ n$} {
      \If{$f_i âˆˆ \sop(g')$} {
        $g' â† g' - \frac{g'_{\lm(f_i)}}{\lc(f_i)}f_i$

        $i â† 1$

        \Break
      }
      \Else{
        $i â† i + 1$
      }
    }
  }
  \Return{$g'$}
\end{algorithm}

Este algoritmo consiste bÃ¡sicamente en siempre buscar entre los elementos de $G$ si hay alguno con el que reducir, y parar cuando ya no hay ninguno.

Una propiedad sobre las estrategias de reducciÃ³n que vamos a necesitar es la siguiente:

\begin{theorem}[Las estrategias de reducciÃ³n mantienen la pertenencia a ideales]\label{thm:e mantiene pertenencia a ideal}
Sean $e_â‰¤$ una estrategia de reducciÃ³n, $F âŠ† KâŸ¨XâŸ©$ y $f âˆˆ (F)$, entonces:
\[ e_â‰¤(F)(f) âˆˆ (F) \]
\end{theorem}
\begin{proof}
Como $e_â‰¤(F)(f)$ es una forma normal de $f$ tenemos $f â†’^*_{â‰¤, F} e_â‰¤(F)(f)$ y por ende por el \cref{thm:S es cerrado en ideal} y que $F âŠ† KâŸ¨XâŸ©$ tenemos $e_â‰¤(F)(f) âˆˆ (F)$.
\end{proof}

\begin{theorem}\label{thm:equivalencias de base de GrÃ¶bner}
Sean $I$ un ideal de $KâŸ¨XâŸ©$ y $G âŠ† KâŸ¨XâŸ©$. Las siguientes afirmaciones son equivalentes:
\begin{enumerate}
\item $G$ es una base de GrÃ¶bner de $I$

\item $âˆ€f âˆˆ KâŸ¨XâŸ© : (f âˆˆ I â‡” f â†’^*_{â‰¤, G} 0)$

\item $âˆ€f âˆˆ KâŸ¨XâŸ© : (f âˆˆ I â‡’ f â†’^*_{â‰¤, G} 0)$

\item $(G) = I âˆ§ âˆ€f âˆˆ I : âˆƒg âˆˆ G : \lm(g) | \lm(f)$

\item $âˆ€f âˆˆ I - \{0\} : âˆƒg_1, â€¦, g_n âˆˆ G, a_1, â€¦, a_n, b_1, â€¦, b_n âˆˆ âŸ¨XâŸ© : \lm(a_i g_i b_i) â‰¤ \lm(f) : f = âˆ‘_{i = 1}^n a_i g_i b_i$
\end{enumerate}
% QuizÃ¡s agregue mas en algÃºn momento

\end{theorem}
\begin{proof} Vamos a probar (1) $â‡’$ (2), (2) $â‡’$ (1), (2) $â‡”$ (3), (2) $â‡’$ (4), (4) $â‡’$ (3), (2) $â‡’$ (5) y (5) $â‡’$ (4).
\begin{description}

\item[(1) $â‡’$ (2)] Supongamos que $G$ es una base de GrÃ¶bner de $I$ y tomemos $f âˆˆ KâŸ¨XâŸ©$. Tenemos que probar $f âˆˆ I â‡” f â†’^*_{â‰¤, G} 0$. Vamos de un lado para el otro:

\begin{DispWithArrows*}
&f âˆˆ I \Arrow{\cref{thm:en ideal â‡” congruente 0}} \\
& â‡” f â‰¡_I 0 \Arrow{\cref{thm:â†’^* = â‰¡}} \\
& â‡” f â†”^*_{â‰¤, G} 0 \Arrow{Al ser $G$ una base de GrÃ¶bner $â†’_{â‰¤, G}$ es confluente y por ende por el \cref{thm:confluente â‡” Church-Rosser} es Church-Rosser, asÃ­ que aplico el sii de Church-Rosser} \\
& â‡” f â†“_{â‰¤, G} 0 \Arrow{DefiniciÃ³n de $â†“$} \\
& â‡” âˆƒf' âˆˆ KâŸ¨XâŸ© : f â†’^*_{â‰¤, G} f' âˆ§ 0 â†’^*_{â‰¤, G} f' \Arrow{Como $0$ es el mÃ­nimo elemento y el \cref{thm:â†’ achican} dice que las reducciones achican el segundo tÃ©rmino del $âˆ§$ ocurre solo para $f' = 0$} \\
& â‡” f â†’^*_{â‰¤, G} 0
\end{DispWithArrows*}

\item[(2) $â‡’$ (1)]
Supongamos (2), o sea $âˆ€f âˆˆ KâŸ¨XâŸ© : (f âˆˆ I â‡” f â†’^*_{â‰¤, G} 0)$. Tenemos que probar que $G$ es una base de GrÃ¶bner de $I$, es decir $(G) = IÂ âˆ§ â†’_{â‰¤, G}$ es confluente.

Probemos cada termino del $âˆ§$ por separado:

\begin{description}
\item[Prueba de $(G) = I$] Tomemos $f âˆˆ KâŸ¨XâŸ©$ y probemos $f âˆˆ (G) â‡” f âˆˆ I$, probando ida y vuelta por separado:

\begin{description}
\item[Ida ($â‡’$)] Supongamos antecedente $f âˆˆ (G)$.

Sean $c_1, â€¦, c_n, c_1', â€¦, c_n' âˆˆ KâŸ¨XâŸ©$, $g_1, â€¦, g_n âˆˆ G$ tales que $f = âˆ‘_{i = 1}^n c_i g_i c_i'$, los cuales existen por la definiciÃ³n de $(\ Â·\ )$.

Definamos $f_0 = f$ y para $i âˆˆ \{1, â€¦, n\}$ $f_i = f_{i-1} - c_i g_i c_i'$.

Notar que tenemos $âˆ€i âˆˆ \{1, â€¦, n\} : f_{i-1} â†’_{â‰¤, G} f_i$ y que $f_n = 0$.

Esto significa que $f â†’^*_{â‰¤, G} 0$ y por ende por (2) vale $f âˆˆ I$.

\item[Vuelta ($â‡$)] Supongamos el antecedente $f âˆˆ I$.

Por (2) tenemos que $f â†’^*_{â‰¤, G} 0$

AsÃ­ que sean $f_0, f_1, â€¦, f_n âˆˆ KâŸ¨XâŸ©$ tales que $f_0 = f$, $f_n = 0$ y $âˆ€i âˆˆ \{1, â€¦, n\} : f_{i-1} â†’_{â‰¤, G} f_i$, los cuales existen por la definiciÃ³n de $^*$.

AdemÃ¡s, para cada $i âˆˆ \{1, â€¦, n\}$ sean $c_i, c_i' âˆˆ KâŸ¨XâŸ©, g_i âˆˆ G$ tales que $f_i = f_{i-1} - c_i g_i c_i'$, los cuales existen por definiciÃ³n de $â†’_{â‰¤, G}$.

Notar que en particular $f_{i-1} = f_i + c_i g_i c_i'$ y por ende $f = âˆ‘_{i = 1}^n c_i g_i c_i'$, lo cual prueba que $f âˆˆ (G)$.

\end{description}

\item[Prueba de $â†’_{â‰¤, G}\text{ es confluente}$]\

Por definiciÃ³n de confluencia alcanza que probar $âˆ€f, f_0, f_1 âˆˆ KâŸ¨XâŸ© : f â†’^*_{â‰¤, G} f_0 âˆ§ f â†’^*_{â‰¤, G} f_1 â‡’ f_0 â†“_{â‰¤, G} f_1$.

AsÃ­ que tomemos $f, f_0, f_1 âˆˆ KâŸ¨XâŸ©$ y probemos el implica yendo de un lado para el otro.
\begin{DispWithArrows*}
&f â†’^*_{â‰¤, G} f_0 âˆ§ f â†’^*_{â‰¤, G} f_1 \\
& â‡’ f_0 â†”^*_{â‰¤, G} f_1 \Arrow{\cref{thm:â†’^* = â‰¡}} \\
& â‡’ f_0 â‰¡_{(G)} f_1 \Arrow{DefiniciÃ³n $â‰¡_{\ Â·\ }$} \\
& â‡’ f_0 - f_1 âˆˆ (G) \Arrow{(6), ya probamos que $(G) = I$} \\
& â‡’ f_0 - f_1 â†’^*_{â‰¤, G} 0 \Arrow{\cref{thm:suma â†’â†“}} \\
& â‡’ (f_0 - f_1) + f_1 â†“_{â‰¤, G} 0 + f_1 \\
& â‡’ f_0 â†“_{â‰¤, G} f_1
\end{DispWithArrows*}
\end{description}

\item[(2) $â‡”$ (3)] La ida es claramente cierta y la vuelta $f âˆˆ I â‡ f â†’^*_{â‰¤, G} 0$ es cierta por el \cref{thm:â†’^* = â‰¡}.

\item[(2) $â‡’$ (4)] Supongamos (2).

La parte de $(G) = I$ es valida porque (2) $â‡’$ (1) y $(G) = I$ es parte de la definiciÃ³n de base de GrÃ¶bner.

Para la parte de $âˆ€f âˆˆ I : âˆƒg âˆˆ G : \lm(g) | \lm(f)$ tomemos $f âˆˆ I$ y mostremos un $g$ que cumple el $âˆƒ$:

Por (2) tenemos $f â†’^*_{â‰¤, G} 0$, esto significa que en alguno de los pasos de el $â†’^*_{â‰¤, G}$ se tiene que reducir el monomio principal de $f$, o sea, uno de los pasos es de la forma $â†’_{â‰¤, a, g, b}$ tal que $a \lm(g) b = \lm(f)$ con $g âˆˆ G, a, b âˆˆ âŸ¨XâŸ©$, por lo tanto, tenemos que $\lm(g) | \lm(f)$.

\item[(4) $â‡’$ (3)] Lo probamos por contradicciÃ³n, o sea, supongamos que vale (4) y que no vale (3). En particular tomemos el mÃ­nimo $f$ tal que $f âˆˆ I$ pero no se cumple que $f â†’^*_{â‰¤, G} 0$.

Por (4) sea $g âˆˆ G$ tal que $\lm(g) | \lm(f)$ y sean tambiÃ©n:
\begin{itemize}
\item $a, b âˆˆ âŸ¨XâŸ©$ tales que $a \lm(g) b = \lm(f)$
\item $f' = f - \frac{f_{\lm_â‰¤(agb)}}{\lc_â‰¤(g)}agb$
\end{itemize}

Notar que $f' âˆˆ I$ ya que $f âˆˆ I$ y $g âˆˆ (G) = I$ y notar que $f â†’_{â‰¤, G} f'$.

AdemÃ¡s por \cref{thm:â†’ achican} $f' < f$.

Y como no vale $f â†’^*_{â‰¤, G} 0$ tampoco puede valer $f' â†’^*_{â‰¤, G} 0$, sin embargo esto contradice que $f$ sea mÃ­nimo.

\item Los casos (2) $â‡’$ (5) y (5) $â‡’$ (4) son muy fÃ¡ciles y quedan como ejercicio. % Pongo esto hasta que la haga

\end{description}
Con esto se termina la prueba.
\end{proof}


\section{Algoritmo de Buchberger}

\begin{definition}
Sean $p, q, a, b, c, d âˆˆ âŸ¨XâŸ©$
\[ (a, b, c, d, p, q)\text{ es una ambigÃ¼edad} â‡” apb = cqd âˆ§ |a|, |b| < |q| âˆ§ |c|, |d| < |p| \]

La ambigÃ¼edad $(a, b, c, d, p, q)$ se dice que es:
\begin{itemize}
\item De superposiciÃ³n $â‡” a = Îµ = d âˆ¨ b = Îµ = c$
\item De inclusiÃ³n $â‡” a = Îµ = b âˆ¨ c = Îµ = d$
\item Relevante $â‡”$ es de superposiciÃ³n o de inclusiÃ³n
\end{itemize}

AdemÃ¡s, si $f, g âˆˆ KâŸ¨XâŸ©$ se dice que $(a, b, c, d, f, g)$ es una ambigÃ¼edad si y solo si $(a, b, c, d, \lm_â‰¤{(f)}, \lm_â‰¤{(g)})$ es una ambigÃ¼edad y lo mismo para ambigÃ¼edades de superposiciÃ³n, de inclusiÃ³n y relevantes.

Sea ademÃ¡s $F âŠ† KâŸ¨XâŸ©$:
\begin{itemize}
\item $\amb(f, g) = \{(a, b, c, d, f, g) : a, b, c, d âˆˆ âŸ¨XâŸ© âˆ§ (a, b, c, d, f, g)\text{ es una ambigÃ¼edad}\}$
\item $\amb(F) = â‹ƒ_{f, g âˆˆ F - \{0\}}{\amb(f, g)}$
\end{itemize}

\end{definition}

\begin{theorem}
Sean $a, b, c, d âˆˆ âŸ¨XâŸ©$ y $f, g âˆˆ KâŸ¨XâŸ©$ entonces si $Î± = (a, b, c, d, f, g)$ es una ambigÃ¼edad tenemos que:
\[ \lm_â‰¤{(afb)} = \lm_â‰¤{(cgd)} \]

\end{theorem}
\begin{proof}\
\begin{DispWithArrows*}
&\lm_â‰¤{(afb)} \Arrow{DefiniciÃ³n de ambigÃ¼edad para polinomios} \\
& = a\lm_â‰¤{(f)}b \Arrow{DefiniciÃ³n de ambigÃ¼edad} \\
& = c\lm_â‰¤{(g)}d \Arrow{DefiniciÃ³n de ambigÃ¼edad para polinomios} \\
& = \lm_â‰¤{(cgd)}
\end{DispWithArrows*}
\end{proof}

Eso motiva la siguiente definiciÃ³n.

\begin{definition}[Monomios principales de ambigÃ¼edades]
Sean $a, b, c, d âˆˆ âŸ¨XâŸ©, f, g âˆˆ KâŸ¨XâŸ©$ y $Î± = (a, b, c, d, f, g)$ una ambigÃ¼edad.
\[ \lm_â‰¤{(Î±)} = \lm_â‰¤{(afb)} \]
\end{definition}

Notar que tambiÃ©n $\lm_â‰¤{(Î±)} = \lm_â‰¤{(cgb)}$

\begin{definition}[S-polinomios]
Sean $a, b, c, d âˆˆ âŸ¨XâŸ©, f, g âˆˆ KâŸ¨XâŸ©$ y $Î± = (a, b, c, d, f, g)$ una ambigÃ¼edad.
\[ \S(Î±) = \frac{afb}{\lc_â‰¤{(f)}} - \frac{cgd}{\lc_â‰¤{(g)}} \]
\end{definition}

\begin{theorem}
Sean $a, b, c, d âˆˆ âŸ¨XâŸ©, f, g âˆˆ KâŸ¨XâŸ©$ y $Î± = (a, b, c, d, f, g)$ una ambigÃ¼edad, entonces:
\[ \lm_â‰¤{(\S(Î±))} < \lm_â‰¤{(Î±)} \]
\end{theorem}
\begin{proof}
Esto es porque en la resta $\frac{afb}{\lc_â‰¤{(f)}} - \frac{cgd}{\lc_â‰¤{(g)}}$ los monomios principales se cancelan.
\end{proof}

\begin{theorem}\label{thm:S es cerrado en ideal}
Sean $I âŠ† KâŸ¨XâŸ©$ un ideal $a, b, c, d âˆˆ âŸ¨XâŸ©, f, g âˆˆ I$ y $Î± = (a, b, c, d, f, g)$ una ambigÃ¼edad, entonces:
\[ \S(Î±) âˆˆ I \]
\end{theorem}
\begin{proof}
En la definiciÃ³n de $\S$ se ve claramente que es una combinaciÃ³n lineal de $f$ y $g$ con elementos de $KâŸ¨XâŸ©$ (en particular con los elementos $\frac{a}{\lc_â‰¤{(f)}}$, $b$, $\frac{c}{\lc_â‰¤{(g)}}$ y $d$)
\end{proof}

\begin{theorem}\label{thm:equivalencias de base de GrÃ¶bner (con ambs)}
Sean $I$ un ideal de $KâŸ¨XâŸ©$ y $G âŠ† KâŸ¨XâŸ©$.

Son equivalentes:
\begin{enumerate}
\item $G$ es una base de GrÃ¶bner de $I$

\item $âˆ€Î± âˆˆ \amb(G) : \S(Î±) â†’^*_{â‰¤, G} 0$

\end{enumerate}
\end{theorem}
% TODO: Agregar prueba. De cualquier manera, Hof no lo prueba a esto

% Agregar algunos teoremas sobre S polinomios, ambigÃ¼edades, y bases de GrÃ¶bner

\begin{definition}[Conjuntos del algoritmo de Buchberger]
Sean $F âŠ† KâŸ¨XâŸ©$ y $e_â‰¤$ una estrategia de reducciÃ³n:
\begin{itemize}
\item $\B_{e_â‰¤}^0(F) = F$
\item $\B_{e_â‰¤}^{i + 1}(F) = \B_{e_â‰¤}^i(F) âˆª \{e_â‰¤(\B_{e_â‰¤}^i(F))(\S(Î±)) : Î± âˆˆ \amb(\B_{e_â‰¤}^i(F))\}$
\item $\B_{e_â‰¤}(F) = â‹ƒ_{i = 0}^âˆ \B_{e_â‰¤}^i(F)$
\end{itemize}
\end{definition}

Estos conjuntos forman esencialmente el algoritmo de Buchberger. Para probar la correctitud vamos a querer probar esto:

\begin{theorem}\label{thm:Buchberger correctitud}
Sean $F âŠ† KâŸ¨XâŸ©$ y $e_â‰¤$ una estrategia de reducciÃ³n, entonces:
\begin{enumerate}
\item $\B_{e_â‰¤}(F)$ es una base de GrÃ¶bner de $(F)$
\item $(F)$ tiene una base de GrÃ¶bner finita $â‡’ âˆƒi âˆˆ â„• : (\B_{e_â‰¤}^i(F))$ es una base de GrÃ¶bner
\end{enumerate}
\end{theorem}

Pero para probar eso primero vamos a probar algunos lemas en el contexto de este teorema.

\begin{lemma}\label{lemma:Buchberger correctitud:3}
$âˆ€i âˆˆ â„• : \B_{e_â‰¤}^{i}(F) âŠ† (F)$
\end{lemma}
\begin{proof}
Por inducciÃ³n en $i$ el caso base es valido porque $F âŠ† (F)$, para el caso inductivo supongamos que vale para $i$ y probemos que vale para $i + 1$:

Tomemos $f âˆˆ \B_{e_â‰¤}^{i + 1}(F)$ y probemos que $f âˆˆ (F)$.

Por la definiciÃ³n recursiva de $\B_{e_â‰¤}^{i + 1}$ tenemos $f âˆˆ \B_{e_â‰¤}^i(F) âˆ¨ âˆƒÎ± âˆˆ \amb(\B_{e_â‰¤}^i(F)) : f = e_â‰¤(\B_{e_â‰¤}^i(F))(\S(Î±))$.

El caso $f âˆˆ \B_{e_â‰¤}^i(F)$ es valido por hipÃ³tesis inductiva. Para el otro caso tomemos ese $Î±$.

Por el \cref{thm:S es cerrado en ideal} tenemos que $\S(Î±) âˆˆ \B_{e_â‰¤}^i(F)$ y por la hipÃ³tesis inductiva que $\S(Î±) âˆˆ (F)$.

Esto implica por el \cref{thm:e mantiene pertenencia a ideal} que $e_â‰¤(\B_{e_â‰¤}^i(F))(\S(Î±)) âˆˆ \B_{e_â‰¤}^i(F)$ y por la hipÃ³tesis inductiva que $e_â‰¤(\B_{e_â‰¤}^i(F))(\S(Î±)) âˆˆ (F)$.
\end{proof}

\begin{lemma}\label{lemma:Buchberger correctitud:4}
$âˆ€i âˆˆ â„• : \B_{e_â‰¤}(F) âŠ† (F)$
\end{lemma}
\begin{proof}
Esto es consecuencia directa de la \cref{lemma:Buchberger correctitud:3} y la definiciÃ³n de $\B_{e_â‰¤}$.
\end{proof}

\begin{lemma}\label{lemma:Buchberger correctitud:5}
$(\B_{e_â‰¤}(F)) = (F)$
\end{lemma}
\begin{proof}
Esto vale porque por el caso base de la definiciÃ³n de $\B_{e_â‰¤}^i$ tenemos $F âŠ† \B_{e_â‰¤}$ y por la \cref{lemma:Buchberger correctitud:4}.
\end{proof}

\begin{lemma}\label{lemma:Buchberger correctitud:6}
$âˆ€Î± âˆˆ \amb(\B_{e_â‰¤}(F)) : \S(Î±) â†’^*_{â‰¤, \B_{e_â‰¤}(F)} 0$
\end{lemma}
\begin{proof}
Tomemos $Î± = (a, b, c, d, f, g) âˆˆ \amb(\B_{e_â‰¤}(F))$ y probemos el $âˆ€$.

Por definiciÃ³n de $\amb$ vale que $f, g âˆˆ \B_{e_â‰¤}(F)$, asÃ­ que sea $i âˆˆ â„•$ el mÃ­nimo tal que $f âˆˆ \B_{e_â‰¤}^i(F)$, $j âˆˆ â„•$ el mÃ­nimo tal que $g âˆˆ \B_{e_â‰¤}^j(F)$ y $k = \max(i, j)$.

Notar que $Î± âˆˆ \amb(\B_{e_â‰¤}^k(F))$ por la definiciÃ³n de $\amb$ y por ende $\S(Î±) âˆˆ \B_{e_â‰¤}(F)$.

Por definiciÃ³n de $â†’^*_{â‰¤, F}$ esto significa que $\S(Î±) â†’^*_{â‰¤, \B_{e_â‰¤}(F)} 0$, asÃ­ que queda probada la afirmaciÃ³n.
\end{proof}

\begin{proof}[DemostraciÃ³n del \cref{thm:Buchberger correctitud}]
Por el \cref{lemma:Buchberger correctitud:5} y el \cref{lemma:Buchberger correctitud:6} vale la equivalencia de base de GrÃ¶bner del \cref{thm:equivalencias de base de GrÃ¶bner (con ambs)}, asÃ­ que (1) queda probado.

Ahora para probar (2) supongamos el antecedente y tomemos $G = \{g_1, â€¦, g_n\}$ una base de GrÃ¶bner finita de $(F)$.

Para cada $i âˆˆ \{1, â€¦, n\}$ sean:
\begin{itemize}
\item $g_{i, 1}, â€¦, g_{i, k_i} âˆˆ \B_{e_â‰¤}(F), a_{i, 1}, â€¦, a_{i, k_i}, b_{i, 1}, â€¦, b_{i, k_i} âˆˆ âŸ¨XâŸ©$ con $\lm(a_{i, j} g_{i, j} n_{i, j}) â‰¤ \lm(g_i)$ tales que $g_i = âˆ‘_{j = 1}^{k_i} a_{i, j} g_{i, j} b_{i, j}$

Los cuales existen por (1) y por (5) del \cref{thm:equivalencias de base de GrÃ¶bner}.

\item $F' = \{g_{i, j} : i âˆˆ \{1, â€¦, n\}, j âˆˆ \{1, â€¦, k_i\}\}$

\item $k âˆˆ â„•$ el mÃ­nimo tal que $F' âŠ† \B_{e_â‰¤}^k(F)$

Notar que $k$ estÃ¡ bien definido porque $F'$ es finito.
\end{itemize}

Ahora vamos a probar que $\B_{e_â‰¤}^k(F)$ es una base de GrÃ¶bner de $(F)$.

Por (5) del \cref{thm:equivalencias de base de GrÃ¶bner} alcanza con probar:

\[ âˆ€f âˆˆ (F) - \{0\} : âˆƒg_1, â€¦, g_n âˆˆ \B_{e_â‰¤}^k(F), a_1, â€¦, a_n, b_1, â€¦, b_n âˆˆ âŸ¨XâŸ© : \lm(a_i g_i b_i) â‰¤ \lm(f) : f = âˆ‘_{i = 1}^n a_i g_i b_i \]

Tomemos $f' âˆˆ (F) - \{0\}$ y escribamoslo de esa forma:

Por (5) del \cref{thm:equivalencias de base de GrÃ¶bner} sean $i'_1, â€¦, i'_{n'} âˆˆ G, a'_1, â€¦, a'_{n'}, b'_1, â€¦, b'_{n'} âˆˆ âŸ¨XâŸ©$ tales que $\lm(a'_i g_{i'_i} b'_i) â‰¤ \lm(f')$ y $f' = âˆ‘_{i = 1}^{n'} a'_i g_{i'_i} b'_i$

\begin{DispWithArrows*}
&f' = âˆ‘_{i = 1}^{n'} a'_i g_{i'_i} b'_i \Arrow{CondiciÃ³n de $g_{i, j}$} \\
& = âˆ‘_{i = 1}^{n'} a'_i (âˆ‘_{j = 1}^{k_{i'_i}} a_{i', j} g_{i, j} b_{i', j}) b'_i \\
& = âˆ‘_{i = 1}^{n'} âˆ‘_{j = 1}^{k_i'} a'_i a_{i', j} g_{i, j} b_{i', j} b'_i
\end{DispWithArrows*}

Sabemos ademÃ¡s que $g_{i',j} âˆˆ \B_{e_â‰¤}^k(F)$ y que $g_{i', j} â‰¤ g_{i'_i} â‰¤ f'$.

Con esto queda completada la prueba.

\end{proof}

La definiciÃ³n de esos conjuntos nos da de forma directa un algoritmo para calcular bases de GrÃ¶bner:

\begin{algorithm}[H] % La H es para que se quede acÃ¡, porque se iba a otra pÃ¡gina. EstarÃ­a bueno hacerlo global
  \caption{Algoritmo de Buchberger}\label{alg:Buchberger}
  \KwData{$F âŠ† KâŸ¨XâŸ©$, $e_â‰¤$ una estrategia de reducciÃ³n}
  \KwResult{$G âŠ† KâŸ¨XâŸ©$ una base de GrÃ¶bner de $(F)$ si es que termina}
  $G â† F$

  \Loop{} {
    $ambs â† \amb(G)$

    $new\_G â† G$

    \For{$Î± âˆˆ ambs$} {
      $f â† e_â‰¤(G)(\S(Î±))$

      \If{$f â‰  0$} {
        $new\_G â† new\_G âˆª \{f\}$
      }
    }

    \If{$new\_G = G$} {
      \Break
    }

    $G â† new\_G$
  }
  \Return{$G$}
\end{algorithm}

El algoritmo asÃ­, si bien es una implementaciÃ³n tal cual de la definiciÃ³n de los conjuntos $\B_{e_â‰¤}^i$ que probamos que es correcta, es muy lenta y necesita un cambio para que pase a andar bien.

Ese cambio es en lugar de para las reducciones usar el conjunto anterior usar tambiÃ©n los nuevos polinomios que ya fueron agregados, es decir, llamar a $e_â‰¤$ con $new\_G$ en lugar de con $G$. Esto lo podemos implementar asÃ­:

\begin{algorithm}[H] % La H es para que se quede acÃ¡, porque se iba a otra pÃ¡gina. EstarÃ­a bueno hacerlo global
  \caption{Primera optimizaciÃ³n de Buchberger}\label{alg:Buchberger optimizaciÃ³n 1}
  \KwData{$F âŠ† KâŸ¨XâŸ©$, $e_â‰¤$ una estrategia de reducciÃ³n}
  \KwResult{$G âŠ† KâŸ¨XâŸ©$ una base de GrÃ¶bner de $(F)$ si es que termina}
  $G â† F$

  $ambs â† \amb(G)$

  \While{$ambs â‰  âˆ…$} {
    elegir $Î± âˆˆ ambs$

    $ambs â† ambs - \{Î±\}$

    $f â† e_â‰¤(G)(\S(Î±))$

    \If{$f â‰  0$} {
      $G â† G âˆª \{f\}$
    }
  }

  \Return{$G$}
\end{algorithm}

Ese cambio hace que pase de no andar rÃ¡pido casi nunca a andar rÃ¡pido en un montÃ³n de casos.

En ese seudocÃ³digo no estÃ¡ aclarado como se elige una ambigÃ¼edad, pero las dos formas que mejor andan son elegir la de menor S-polinomio y elegir la que hace mas tiempo estÃ¡ en el conjunto de ambigÃ¼edades (first in first out).

\chapter{ImplementaciÃ³n}

En este capitulo se explican los detalles de como estÃ¡ hecha la implementaciÃ³n.

\section{Monomios}

Para los monomios, o sea los elementos de $âŸ¨XâŸ©$, la base de la implementaciÃ³n es asÃ­:

\begin{lstlisting}[language=C++]
  struct Monomial {
    typedef __uint8_t X;
    vector<X> vals;
  };
\end{lstlisting}

El tipo \texttt{Monomial::X} es el tipo en el que se guardan las variables, con el cÃ³digo asÃ­ como estÃ¡ son nÃºmeros de 8 bits, por lo cual puede haber hasta 256 variables, si fuera necesario usar mas variables hay que cambiarlo por un tipo mas grande como \texttt{\_\_uint16\_t}. Se podrÃ­a haber usado un argument de template para que se pueda cambiar sin tener que cambiar el cÃ³digo, pero no estÃ¡ hecho para simplificar el cÃ³digo, ya que para los polinomios ya hay dos argumentos de template.

Este struct tiene implementada las operaciones bÃ¡sicas con monomios incluyendo el producto, mÃ©todos para saber divisibilidad de monomios y dividir monomios tanto obteniendo todas las respuestas como obteniendo una respuesta y mÃ©todos para leer e imprimir monomios tanto de forma bonita como se los suele escribir (para monomios que tienen variables menores a 26) como en un formato fÃ¡cil de leer desde otro cÃ³digo.

El formato fÃ¡cil de leer desde cÃ³digo consiste en un nÃºmero entero no negativo $n$ seguido de $n$ nÃºmeros $x_1$, â€¦, $x_n$ que son los nÃºmeros de variables. Cuando $n = 0$ no hay ningÃºn $x_i$. Se puede representar asÃ­ el formato:

\begin{lstlisting}[escapechar=+]
  +$n$+ +$x_1$+ â€¦ +$x_n$+
\end{lstlisting}

\section{Orden monomial}

El Ãºnico orden monomial que estÃ¡ implementado es el orden lexicogrÃ¡fico por grado y estÃ¡ implementado asÃ­:

\begin{lstlisting}[language=C++]
  struct DegLexOrd {
    bool operator()(const Monomial& a, const Monomial& b) const {
      size_t n = a.vals.size(), m = b.vals.size();
      return n < m || (n == m && a.vals < b.vals);
    }
  };
\end{lstlisting}

Esto estÃ¡ definido a parte y no como definir el operador \texttt{<=} para \texttt{Monomial} por si se quiere usar otro orden monomial.

\section{Polinomios}

Para los polinomios, o sea los elementos de $KâŸ¨XâŸ©$, la base de la implementaciÃ³n es asÃ­:

\begin{lstlisting}[language=C++]
  template<typename K, class ord = DegLexOrd>
  struct Poly {
    vector<pair<Monomial, K>> terms;
  };
\end{lstlisting}

El parÃ¡metro de template \texttt{K} es el cuerpo de los coeficientes, por lo general los racionales o la aritmÃ©tica mÃ³dulo algÃºn primo y el parÃ¡metro de template \texttt{ord} es el orden monomial que se va a usar, por defecto es el orden lexicogrÃ¡fico por grado.

\texttt{K} tiene que tener implementada todas las operaciones de cuerpo y un constructor que pueda tomar un \texttt{int} o algo a lo que \texttt{int} se castee automÃ¡ticamente

El vector \texttt{terms} tiene los tÃ©rminos del polinomio con cada monomio con coeficiente distinto de cero apareciendo exactamente una vez y se mantiene siempre ordenado por el orden monomial.

Este struct tiene implementada las operaciones bÃ¡sicas con polinomios incluyendo la suma y el producto, mÃ©todos para leer e imprimir polinomios tanto de forma bonita como se los suele escribir como en un formato fÃ¡cil de leer desde otro cÃ³digo y el orden polinomial correspondiente al orden monomial.

El formato fÃ¡cil de leer desde cÃ³digo consiste en, primero un nÃºmero entero no negativo $m$, la cantidad de tÃ©rminos, seguido de la descripciÃ³n de $m$ tÃ©rminos. La descripciÃ³n de cada tÃ©rmino consiste en primero el coeficiente y despuÃ©s la descripciÃ³n del monomio. El coeficiente tiene se lee haciendo \texttt{>> c} donde \texttt{c} es una variable de tipo \texttt{K}, asÃ­ que \texttt{K} tiene que tener \texttt{>>} implementado para que se pueda leer polinomios. Se puede representar asÃ­ el formato:

\begin{lstlisting}[escapechar=+]
  +$m$+
  +$c_1$+ +$n_1$+ +$x_{1, 1}$+ â€¦ +$x_{1, n_1}$+
  á§
  +$c_m$+ +$n_m$+ +$x_{m, 1}$+ â€¦ +$x_{m, n_m}$+
\end{lstlisting} % Los tres puntitos verticales por algÃºn motivo no se muestran ni con ese caracter ni con â‹®


\end{document}
