\documentclass{amsbook}
\usepackage{fontspec}
\usepackage{enumitem}
\defaultfontfeatures{Renderer=Basic,Ligatures={TeX}}
\usepackage[math-style=ISO,bold-style=ISO]{unicode-math}
\setmathfont{Asana Math}

\usepackage[margin=5mm]{geometry} % Adjust the margin values as desired

\usepackage[ruled, vlined, linesnumbered]{algorithm2e}
\SetKw{KwEnd}{}
\DontPrintSemicolon

\newtheoremstyle{customstyle} % <name>
{10pt} % <Space above>
{10pt} % <Space below>
{} % <Body font>
{1em} % <Indent amount>
{\bfseries} % <Theorem head font>
{:} % <Punctuation after theorem head>
{.5em} % <Space after theorem head>
{} % <Theorem head spec (can be left empty, meaning `normal`)

\theoremstyle{customstyle}
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\renewcommand{\proofname}{\textbf{Demostración:}}

\newcommand{\definición}[2][]{
  \begin{definition}[#1]
  \setlength{\parindent}{2em} % Ajustar la indentación del contenido
  #2
  \qed
  \end{definition}
}

\newcommand{\teorema}[2][]{
  \begin{theorem}[#1]
  \setlength{\parindent}{2em} % Ajustar la indentación del contenido
  #2
  \qed
  \end{theorem}
}

\newcommand{\teoremaConDemostración}[3][]{
  \begin{theorem}[#1]
  \setlength{\parindent}{2em} % Ajustar la indentación del contenido
  #2
  \end{theorem}
  \begin{proof}
  #3
  \end{proof} % Esto ya pone un □ solo
}

\DeclareMathOperator{\sop}{sop}
\DeclareMathOperator{\lm}{lm}
\DeclareMathOperator{\lc}{lc}
\DeclareMathOperator{\lt}{lt}
\DeclareMathOperator{\tail}{tail}
\DeclareMathOperator{\amb}{amb}
\renewcommand{\S}{\text{S}}
\DeclareMathOperator{\B}{B}


\begin{document}
\fontsize{16pt}{19pt}\selectfont % Increase the font size


\section{Definiciones preliminares}

En esta sección se explican los conceptos matemáticos necesarios para entender el resto del trabajo.
En particular se explica …. % Completar

\subsection{Sistemas de re-escritura}

En esta sub-sección se explican algunas definiciones básicas de sistemas de re-escritura.

Para toda está sección fijemos un conjunto $A$ y $→ ⊆ A^2$ una relación sobre $A$.

\definición[Formas normales] {
Sean $a, b ∈ A$:

  $a$ está en forma normal $⇔ ∄x ∈ A : a → x$

  $b$ es forma normal de $a ⇔ a →^* b ∧ b$ está en forma normal

  $a$ tiene forma normal $⇔ ∃x ∈ A : x$ es forma normal de $a$

  $a ↓ b ⇔ ∃x ∈ A : a → x ∧ b → x$
}

\definición[] {: % ARREGLAR

  $→$ es confluente $⇔ ∀x, y, z ∈ A : x →^* y ∧ x →^*z ⇒ y ↓ z$

  $→$ es normalizante $⇔ ∀x ∈ A : x$ tiene forma normal

  $→$ es terminante $⇔ ∄X ∈ A^ℕ : ∀i ∈ ℕ : X_i → X_{i + 1}$
}


\subsection{Álgebra libre}

\definición[Monomio libre] {
Sea $X$ un alfabeto finito:

  $⟨X⟩ = X^*$

Y a $⟨X⟩$ se lo llama monomios libres sobre $X$.
}

A partir de ahora fijamos $X$ un alfabeto finito. En $⟨X⟩$ se define el producto como la concatenación:

\definición[Producto de monomio libre] {: % ARREGLAR

  $· : ⟨X⟩^2 → ⟨X⟩$

  $v · w = vw$

Y a la estructura $(⟨X⟩, ·)$ se la llama monoide libre sobre $⟨X⟩$.
}

\definición[Divisibilidad] {
Sean $v, w ∈ ⟨X⟩$:

  $v | w ⇔ ∃a , b ∈ ⟨X⟩ : w = avb$

Y cuando $v | w$ se dice que $v$ divide a $w$.
}

Mas adelante va a ser falta tener un orden entre los elementos de $⟨X⟩$, pero no es necesario fijar uno concreto, así que lo que vamos a hacer es definir las propiedades que tienen que tener un orden para servir y trabajar con un orden cualquiera que las cumpla.

\definición[Buen orden monomial] {
Sea $≤$ un orden total sobre $⟨X⟩$:

  $≤$ es un buen orden monomial si y solo si:
\begin{enumerate}[label=(\alph*)]
\item $∀v, w, a, b ∈ ⟨X⟩ : v ≤ w ⇒ avb ≤ awb$

\item $∀S ⊆ ⟨X⟩ : S ≠ Ø ⇒ S$ tiene mínimo elemento con respecto a $≤$
\end{enumerate}
}

Ahora un ejemplo de orden que cumple con esta definición:

\definición[Orden lexicográfico por grado] {
Fijemos $X = \{x_1, …, x_n\}$ y un orden total entre $X$: $x_1 ≤ … ≤ x_n$, el cual se extiende (como es usual) de forma lexicográfica a $⟨X⟩$

El orden lexicográfico por grado se define así:

  $≤_{deglex} ⊆ ⟨X⟩^2$

  $a ≤_{deglex} b ⇔ |a| < |b| ∨ (|a| = |b| ∧ a ≤ b)$
}

O sea, el orden lexicográfico por grado es orden primero por cardinalidad, que se llama grado también, y desempatar por orden lexicográfico.

A partir de ahora fijamos un buen orden monomial $≤$, y usaremos $<$, $≥$ y $>$ como se usan habitualmente.

Ahora una propiedad sobre el orden monomial que es consecuencia directa de b de la definición:

\teorema[$≤$ no tiene cadenas estrictamente decrecientes infinitas] {

  $∄M ∈ ⟨X⟩^ℕ : ∀i ∈ ℕ : M_{i + 1} < M_i$

}

\definición[Álgebra libre (asociativa)] {
Sea $R$ un anillo conmutativo

Se define $R⟨X⟩$ la $R$-álgebra libre sobre $X$ como:

  $R⟨X⟩ = \{\sum_{i = 1}^n c_i w_i : c_1, …, c_n ∈ R, w_1, …, w_n ∈ ⟨X⟩\}$

La suma en $R⟨X⟩$ se define de la manera esperable.

El producto por escalares de define como:

  $c (\sum_{i = 1}^n c_i w_i) = (\sum_{i = 1}^n c c_i w_i)$

El producto entre elementos de $R⟨X⟩$ se define como:

  $(\sum_{i = 1}^n c_i w_i) · (\sum_{i = 1}^m c'_i w'_i) = \sum_{i = 1}^n \sum_{j = 1}^m c_i c'_j w_i w_j$

A los elementos de $R⟨X⟩$ se los llama polinomios no conmutativos.
% Esta definición creo que hay que mejorarla, pero no se como
}

Algunos ejemplos de polinomios no conmutativos sobre $ℚ⟨\{a, b, c\}⟩$ son los siguientes:

$p_0 = a$

$p_1 = ab + cb$

$p_2 = 3 abb + 4 bcca - 2 acab$

Notar que $p_1 ≠ ab + bc$ ya que el producto es no conmutativo.

Sobre los polinomios no conmutativos se hacen las siguientes definiciones, que serán de utilidad:


\definición[] {
Sean $R$ un anillo conmutativo, $p ∈ R⟨X⟩$, $c_1, …, c_n ∈ R$, $w_1, …, w_n, w ∈ ⟨X⟩$, $f = \sum_{i = 1}^n c_i w_i$ y $≤$ un buen orden monomial

Se define:

  $f_w = \left\{\begin{array}{ll} w = w_i → c_i \\ \text{si no} → 0  \end{array} \right. $

  $\sop(f) = \{w_1, …, w_n\}$

  $\lm_≤(f) = \min_≤(\sop(f))$

  $\lc_≤(f) = f_{\lm(f)}$

  $\lt_≤(f) = \lc_≤(f) · \lm_≤(f)$

  $\tail_≤(f) = f - \lt_≤(f)$

  $f$ es mónico $⇔ \lc_≤(f) = 1$

A $\sop(f)$ se lo llama soporte de $f$, a $\lm_≤(f)$ se lo llama monomio principal de $f$, a $\lc_≤(f)$ se lo llama coeficiente principal de $f$ y a $\lt_≤(f)$ se lo llama término principal de $f$.

}

\teorema[]{
Sea $R$ un anillo conmutativo, entonces:

  $(R⟨X⟩, +, ·)$ es un anillo

}

Esto significa que aplican todas las definiciones y teoremas de anillo.
En particular vale la definición de ideal, que como es muy importante para este trabajo la escribo acá también:

\definición[Ideal] {
Sean $R$ un anillo e $I, B ⊆ R$

  $I$ es un ideal de $R ⇔$:
\begin{enumerate}[label=(\alph*)]
\item $I ≠ Ø$

\item $∀a, b ∈ I : a + b ∈ I$

\item $∀a ∈ I, r, r' ∈ R : rar' ∈ I$
\end{enumerate}

  $(B) = \{\sum_{i = 1}^n c_i b_i c_i' : n ∈ ℕ, b_1, …, b_n ∈ B, c_1, …, c_n, c_1', …, c_n' ∈ R\}$
}

Además se puede probar que $(B)$ es un ideal de $R$ y a $(B)$ se lo llama el ideal generado por $B$.

A partir de ahora fijamos un cuerpo $K$.

Una pregunta que surge es dado un conjunto finito $G ⊆ K⟨X⟩$ y un elemento $f ∈ K⟨X⟩$, ¿se puede calcular si $f ∈ (G)$?

La respuesta a esa pregunta es que no, porque el problema es indecible

% Acá hay que explicar que ese problema no es computable, pero que se puede hacer un intento …

Mas adelante va a hacer falta comprar no solo monomios si no también polinomios, así que $≤$ se extiende a $K⟨K⟩$ así:

\definición[Extensión de orden monomial a polinomios] {
Sean $f, g ∈  K⟨X⟩$:

  $f < g ⇔ (f = 0 ∧ g ≠ 0) ∨ \lm(f) < \lm(g) ∨ (\lm(f) = \lm(g) ∧ \tail(f) < \tail(g))$

}

Es decir, el orden en los polinomios es orden lexicográfico con el polinomio visto como una lista de monomios, sin coeficientes ordenada de mayor a menor.

Ahora algunos teoremas sobre el orden de los polinomios.

\teorema[] {
$<$ como relación de $K⟨X⟩$ es un pre-orden.
}

\teoremaConDemostración[$<$ como relación de $K⟨X⟩$ no tiene cadenas estrictamente decrecientes infinitas] {
  $∄P ∈ K⟨X⟩^ℕ : ∀i ∈ ℕ : P_{i + 1} < P_i$
}{
Supongamos que existe tal $P$ y tomemos uno que minimize $\lm(P_1)$ (1)

(tomar este mínimo está bien por el teorema ...) % Mencionar el teorema sobre monomios

Notar que:

(2) $∀i ∈ ℕ : \lm(P_i) = \lm(P_1)$

  Esto ya que no puede ser $\lm(P_i) < \lm(P_1)$ porque entonces $P_i, P_{i + 1}, …$ sería una cadena estrictamente decreciente infinita que rompería (1).


(3) $\tail(P_1), \tail(P_2), …$ es una cadena estrictamente decreciente infinita.

  Esto por aplicar la definición del orden polinomial y (2).

(4) $P_1 ≠ 0$

  Esto por que claramente $0$ es un mínimo.

Sin embargo, (3) contradice (1) ya que por (4) $\lm(\tail(P_1)) < \lm(P_1)$.

}



\definición[Reducciones] {
Sean $G ⊆ K⟨X⟩$, $g ∈ K⟨X⟩ - \{0\}$, $a, b ∈ ⟨X⟩$ y $f, f' ∈ K⟨X⟩$:

  $f →_{≤, a, g, b} f' ⇔ \lm_≤(agb) ∈ \sop(f) ∧ f' = f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb$

  $→_{≤, g} = \bigcup_{a, b ∈ ⟨X⟩} →_{≤, a, g, b}$

  $→_{≤, G} = \bigcup_{g ∈ K⟨X⟩ - \{0\}} →_{≤, g}$
}

\teorema[]{
Sea $G ⊆ K⟨X⟩$, entonces:

  $→_{≤, G}$ es normalizante

  $→_{≤, G}$ es terminante
} %{ % Hay que agregar la demostración

%$→_{≤, G}$ es normalizante: % A completar

%   $→_{≤, G}$ es normalizante

% $⇔$

%   $∀x ∈ K⟨X⟩ : x$ tiene forma normal

% $⇔$

%   $∀x ∈ K⟨X⟩ : ∃y ∈ K⟨X⟩ : y$ es forma normal de $x$

% $⇔$

%   $∀x ∈ K⟨X⟩ : ∃y ∈ K⟨X⟩ : x →^* y ∧ y$ está en forma normal

% $⇔$

%   $∀x ∈ K⟨X⟩ : ∃y ∈ K⟨X⟩ : x →^* y ∧ ∄z ∈ K⟨X⟩ : y → z$

%$→_{≤, G}$ es terminante:

%}

Sin embargo $→_{≤, G}$ no necesariamente es confluente, eso motiva las siguientes dos definiciones.

\definición[Bases de Gröbner] {
Sean $I$ un ideal de $K⟨X⟩$ y $G ⊆ K⟨X⟩$:

  $G$ es una base de Gröbner de $I ⇔ (G) = I ∧ →_{≤, G}$ es confluente

  $G$ es una base de Gröbner reducida de $I ⇔ G$ es una base de Gröbner de $I ∧ ∀g ∈ G : g$ es irreducible con respecto a $→_{≤, G - \{g\}}$

}

\definición[Estrategia de reducción] {
Sea $e_≤ : 𝒫(K⟨X⟩) → K⟨X⟩ → K⟨X⟩$

Se define:

  $e_≤$ es una estrategia de reducción $⇔$

    $∀G ⊆ K⟨X⟩, f ∈ K⟨X⟩ : e_≤(G)(f)$ es forma normal de $f$ con respecto a $→_{≤, G}$
}

En los casos en los que $G$ es confluente hay una sola $e_≤(G)$ posible, pero cuando no es confluente puede haber muchas.


\subsection{Algoritmo de Buchberger}

\definición[Ambigüedades] {
Sean $p, q, a, b, c, d ∈ ⟨X⟩$

  $(a, b, c, d, p, q)$ es una ambigüedad $ ⇔ apb = cqd ∧ |a|, |b| < |q| ∧ |c|, |d| < |p|$

La ambigüedad $(a, b, c, d, p, q)$ se dice que es:

  De superposición $⇔ a = ε = d ∨ b = ε = c$

  De inclusión $⇔ a = ε = b ∨ c = ε = d$

  Relevante $⇔$ es de superposición o de inclusión

Además, si $f, g ∈ K⟨X⟩$ se dice que $(a, b, c, d, f, g)$ es una ambigüedad si y solo si $(a, b, c, d, \lm_≤{(f)}, \lm_≤{(g)})$ es una ambigüedad y lo mismo para ambigüedades de superposición, de inclusión y relevantes.

Sea además $G ⊆ K⟨X⟩$:

  $\amb(f, g) = \{(a, b, c, d, f, g) : a, b, c, d ∈ ⟨X⟩ ∧ (a, b, c, d, f, g)\text{ es una ambigüedad}\}$

  $\amb(G) = \bigcup_{f, g ∈ G - \{0\}}{\amb(f, g)}$

}

\teorema[]{
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩, α = (a, b, c, d, f, g)$ una ambigüedad, entonces:

  $\lm_≤{(afb)} = \lm_≤{(cgd)}$

}


Eso motiva la siguiente definición.

\definición[Monomios principales de ambigüedades] {
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩$ y $α = (a, b, c, d, f, g)$ una ambigüedad.

  $\lm_≤{(α)} = \lm_≤{(afb)}$
}

Notar que también $\lm_≤{(α)} = \lm_≤{(cgb)}$

\definición[S-polinomios] {
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩$ y $α = (a, b, c, d, f, g)$ una ambigüedad.

  $\S(α) = \frac{afb}{\lc_≤{(f)}} - \frac{cgd}{\lc_≤{(g)}}$
}

\teorema[]{
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩, α = (a, b, c, d, f, g)$ una amiguedad, entonces:

  $\lm_≤{(\S(α))} < \lm_≤{(α)}$

}

% Agregar algunos teoremas sobre S polinomios, ambigüedades, y bases de Gröbner

\definición[Conjuntos del algoritmo de Buchberger] {
Sean $G ⊆ K⟨X⟩$ y $e_≤$ una estrategia de reducción:

  $\B_{e_≤}^0(G) = G$

  $\B_{e_≤}^{i + 1}(G) = \B_{e_≤}^i(G) ∪ \{e_≤(\B_{e_≤}^i(G))(\S(α)) : α ∈ \amb(\B_{e_≤}^i(G))\}$

  $\B_{e_≤}(G) = \bigcup_{i = 0}^∞ \B_{e_≤}^i(G)$

}

\teorema[]{
  Sean $G ⊆ K⟨X⟩$ y $e_≤$ una estrategia de reducción, entonces:

  $\B_{e_≤}(G)$ es una base de Gröbner de $(G)$

  $(G)$ tiene una base finita $⇒ ∃i ∈ ℕ : (\B_{e_≤}^i(G)) = (G)$
}



% \begin{algorithm}
%   \caption{Buchberger}
%   \KwData{Datos de entrada}
%   \KwResult{Resultado esperado}
%   Inicializar variables\;
%   \For{cada elemento en la lista}{
%     \If{condición}{
%       Realizar acción
%     }
%     \Else{
%       Realizar otra acción
%     }
%   }
% \end{algorithm}


\end{document}
