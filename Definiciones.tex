\documentclass{amsbook} % [fleqn] hace que las ecuaciones con \[  \] estén a la izquierda

\usepackage{polyglossia}
\setdefaultlanguage{spanish}

\usepackage{amsthm}
\usepackage{fontspec}
\usepackage{enumitem}
\usepackage[bookmarks]{hyperref}
\defaultfontfeatures{Renderer=Basic,Ligatures={TeX}}
\usepackage[math-style=ISO,bold-style=ISO]{unicode-math}
\setmathfont{Asana Math}
\usepackage{witharrows}
\WithArrowsOptions{fleqn,displaystyle,i,tikz={font={\small\normalfont}},ygap=0.5em,wrap-lines}

\hfuzz=50pt % Elimina warnings de "Overfull \hbox"

\usepackage[margin=5mm]{geometry} % Adjust the margin values as desired

\usepackage{float}
\usepackage[ruled, vlined, linesnumbered]{algorithm2e}
\SetKw{Break}{break}
\SetKwFor{Loop}{loop}{}{end loop}

\usepackage{listings} % Me gustaría hacer que use un syntax highlighting bonito (el por defecto es solo normal/negrita)
\lstset{basicstyle=\ttfamily} % Cambia la fuente a monospace y ajusta el tamaño de la fuente

\usepackage[capitalise]{cleveref}

\setlist[enumerate,1]{label={\em{(\arabic*)}}}

\newtheoremstyle{customstyle} % <name>
{} % <Space above>
{} % <Space below>
{\slshape} % <Body font> % Preguntar que opinan, y porque hay un warning
{1.5em} % <Indent amount>
{\bfseries} % <Theorem head font>
{.} % <Punctuation after theorem head>
{.5em} % <Space after theorem head>
{} % <Theorem head spec (can be left empty, meaning `normal`)

\theoremstyle{customstyle}
\newtheorem{definition}{Definición}[chapter]
\newtheorem{theorem}{Teorema}[chapter]
\newtheorem{lemma}{Lema:}[chapter]
\addto\captionsspanish{\renewcommand{\proofname}{Demostración}}
\renewenvironment{proof}[1][\proofname]{{\bfseries #1: }}{\qed} % Cambiar estilo del título de la demostración

\newtheoremstyle{factstyle} % <name>
{} % <Space above>
{} % <Space below>
{\normalfont} % <Body font> % Preguntar que opinan, y porque hay un warning
{1.5em} % <Indent amount>
{\bfseries} % <Theorem head font>
{.} % <Punctuation after theorem head>
{.5em} % <Space after theorem head>
{} % <Theorem head spec (can be left empty, meaning `normal`)

\theoremstyle{factstyle}
\newtheorem{fact}{Afirmación}[theorem]



\DeclareMathOperator{\sop}{sop}
\DeclareMathOperator{\lm}{lm}
\DeclareMathOperator{\lc}{lc}
\DeclareMathOperator{\lt}{lt}
\DeclareMathOperator{\tail}{tail}
\DeclareMathOperator{\amb}{amb}
\renewcommand{\S}{\text{S}}
\DeclareMathOperator{\B}{B}


\begin{document}
\fontsize{16pt}{19pt}\selectfont % Increase the font size

\chapter{Introducción informal}

En esta sección se explica informalmente mas o menos de que se trata el tema de la tesis.

Usted posiblemente haya escuchado hablar de los polinomios de varias variables, esos como $5  + 3 y - 2 x y + x^3 y^5$ y que todo el conjunto de los polinomios con, por ejemplo, variables $x, y$ sobre un cuerpo $K$ se denota como $K[x, y]$.

En esos polinomios es producto entre las variables conmuta, así que es lo mismo el polinomio $x y$ que el polinomio $y x$. Se puede considerar que eso no pasa, que el producto de las variables no conmuta, así que $x y ≠ y x$, (pero que el producto de las variables con los coeficientes si conmuta, así que por ejemplo $x 3 y = 3 x y$). Al hacer eso se obtiene algo como los polinomios, pero en el que los monomios son palabras. A esos polinomios se los llama polinomios no conmutativos y, por ejemplo, para las variables $x, y$ con coeficientes en un cuerpo $K$ se denota como $K⟨x, y⟩$ y en general si $X$ es un alfabeto, $K⟨X⟩$ es el conjunto de los polinomios no conmutativos sobre $X$.

Una problema de decisión que existe sobre los polinomios no conmutativos es, dado un conjunto $G$ de polinomios no conmutativos y un polinomio no conmutativo $f$ es decidir si $f$ se pude escribir como combinación lineal lineal de elementos de $G$ con coeficientes en $K⟨X⟩$, o escrito formalmente determinar si:

\[ ∃n ∈ ℕ, g_1, …, g_n ∈ F, f_1, …, f_n, f'_1, …, f'_n ∈ K⟨X⟩ : f = ∑_{i = 1}^n f_i g_i f'_i \]

Este problema en el caso general no es computable, pero si se puede hacer un algoritmo que si es verdadero termina y si no puede no terminar, o hacer un algoritmo que intenta determinarlo y puede devolver que si, que no, o que no sabe pero podría llegar a averiguarlo si sigue computando (así como podría no averiguarlo nunca).

Para se considera el conjunto $(G)$ de todos los polinomios no conmutativos que satisfacen ese $∃$ y se calcula algo que se llama una base de Gröbner de $(G)$, la cual puede ser finita o infinita computacionalmente enumerable y son estos últimos casos los que hacen que el problema no sea computable.

Para calcular esas bases de Gröbner hay dos algoritmos principales, llamados algoritmo de Buchberger y F4.

Antes de ahora ya hubo varias implementaciones de esos algoritmos, siendo la mas importante \texttt{operator\_gb} hecha por Clemens Hofstadler en python usando \texttt{sagemath} y que está explicada en … % Citar a Hof
junto con una explicación de toda la teoría (mucho mas en detalle que en esta tesis).

Como esa implementación está hecha en python y no corre en paralelo, el objetivo de esta tesis fue implementar en C++ esos algoritmos y hacerlos correr en paralelo.

\chapter{Definiciones preliminares}

En esta sección se explican los conceptos matemáticos necesarios para entender el resto del trabajo.
En particular se explica …. % Completar

\section{Sistemas de re-escritura}

En esta sub-sección se explican algunas definiciones y teoremas básicos de sistemas de re-escritura.

Para toda está sección fijemos un conjunto $A$.

\begin{definition} Sean $→, ⟿ ⊆ A^2$ relaciones sobre $A$:
\begin{itemize}
\item $→ ∘ ⟿ = \{(x, z) ∈ A^2 : ∃y ∈ A : x → y ∧ y ⟿ z\}$
\item $→^0 = \{(x, x) : x ∈ A\}$
\item $→^{n + 1} = →^n ∘ →$
\item $→^* = ⋃_{n = 0}^∞ →^n$
\item $← = \{(y, x) ∈ A^2 : (x, y) ∈ →\}$
\item $↔ = → ∪ ←$
\end{itemize}
\end{definition}

Para el resto de la sección fijemos $→$ una relación sobre $A$.

\begin{definition}\

\begin{itemize}
\item $a$ está en forma normal $⇔ ∄x ∈ A : a → x$
\item $b$ es forma normal de $a ⇔ a →^* b ∧ b$ está en forma normal
\item $a$ tiene forma normal $⇔ ∃x ∈ A : x$ es forma normal de $a$
\item $a ↓ b ⇔ ∃x ∈ A : a →^* x ∧ b →^* x$
\end{itemize}
\end{definition}

\begin{definition}\

\begin{itemize}
\item $→$ es confluente $⇔ ∀x, y, z ∈ A : x →^* y ∧ x →^*z ⇒ y ↓ z$
\item $→$ es Church-Rosser $⇔ ∀x, y ∈ A : x ↔️^* y ⇔ x ↓ y$
\item $→$ es normalizante $⇔ ∀x ∈ A : x$ tiene forma normal
\item $→$ es terminante $⇔ ∄X ∈ A^ℕ : ∀i ∈ ℕ : X_i → X_{i + 1}$
\end{itemize}
\end{definition}

\begin{theorem}\label{thm:terminante ⇒ normalizante}
$→$ es terminante $⇒ →$ es normalizante
\end{theorem}

\begin{theorem}\label{thm:confluente ⇔ Church-Rosser}
$→$ es confluente $⇔ →$ es Church-Rosser
\end{theorem}

\section{Álgebra libre}

Ahora si empezamos con el tema de la tesis en si.

\begin{definition}
Sea $X$ un alfabeto finito. Se define la estructura $(⟨X⟩, ·)$ de la siguiente manera:
\begin{itemize}
\item $⟨X⟩$ son las palabras finitas sobre $X$
\item $· : ⟨X⟩^2 → ⟨X⟩$ es la concatenación
\end{itemize}
A los elementos de $⟨X⟩$ se los llama monomios libres sobre $X$, a $·$ el producto de $⟨X⟩$ y a $(⟨X⟩, ·)$ el monoide libre sobre $X$.
\end{definition}

Por ejemplo, si $X = \{a, b, c\}$ algunos monomios son:

\begin{align*}
m_0 &= abbcb \\
m_1 &= bbc \\
m_2 &= bcb \\
m_3 &= ε \\
m_1 · m_2 &= bccbcb
\end{align*}

El $ε$ de $m_3$ es la palabra vacía. Notar que $m_1 ≠ m_2$ ya que el producto es no es conmutativo.

A partir de ahora fijamos $X$ un alfabeto finito.

\begin{definition}
Sean $v, w ∈ ⟨X⟩$:
\begin{itemize}
\item $v | w ⇔ ∃a , b ∈ ⟨X⟩ : w = avb$
\end{itemize}

Y cuando $v | w$ se dice que $v$ divide a $w$.
\end{definition}

Y en el ejemplo de antes tenemos por ejemplo $m_1 | m_0$ ya que $m_0 = a m_1 b$.

Mas adelante será necesario tener un orden entre los elementos de $⟨X⟩$, pero no es necesario fijar uno concreto, así que lo que vamos a hacer es definir las propiedades que tienen que tener un orden para servir y trabajar con un orden cualquiera que las cumpla.

\begin{definition}
Sea $≤$ un orden total sobre $⟨X⟩$, definimos que $≤$ es un buen orden monomial si y solo si:
\begin{enumerate}
\item $∀v, w, a, b ∈ ⟨X⟩ : v ≤ w ⇒ avb ≤ awb$

\item $∀S ⊆ ⟨X⟩ : S ≠ ∅ ⇒ S$ tiene mínimo elemento con respecto a $≤$
\end{enumerate}
\end{definition}

Ahora un ejemplo de orden que cumple con esta definición:

\begin{definition}
Fijemos $X = \{x_1, …, x_n\}$ y un orden total sobre $X$: $x_1 ≤ … ≤ x_n$, el cual se extiende (como es usual) de forma lexicográfica a $⟨X⟩$. El orden lexicográfico por grado $ ≤_{deglex}$ sobre $⟨X⟩$ se define así:
\[ a ≤_{deglex} b ⇔ |a| < |b| ∨ (|a| = |b| ∧ a ≤ b) \]
\end{definition}

O sea, el orden lexicográfico por grado es orden primero por cardinalidad, que se llama grado también, y desempatar por orden lexicográfico, por ejemplo tenemos $bc ≤_{deglex} abb$, $aabbc ≤_{deglex} abbcc$ y $ε ≤_{deglex} a$.

Se puede probar fácilmente que este orden es un bueno orden monomial.

A partir de ahora fijamos un buen orden monomial $≤$, y usaremos $<$, $≥$ y $>$ como se usan habitualmente.

Ahora una propiedad sobre el orden monomial que es consecuencia directa de la definición:

\begin{theorem}\label{thm:≤ no cadenas dec inf}
La relación $≤$ no tiene cadenas estrictamente decrecientes infinitas
\end{theorem}

Ahora pasamos a hablar de sumar monomios entre si para tener polinomios no conmutativos.

\begin{definition}[Álgebra libre (asociativa)]
Sea $R$ un anillo conmutativo. Se define $R⟨X⟩$ la $R$-álgebra libre sobre $X$ como:
\[ R⟨X⟩ = \{∑_{i = 1}^n c_i w_i : c_1, …, c_n ∈ R, w_1, …, w_n ∈ ⟨X⟩\} \]

La suma en $R⟨X⟩$ se define de la manera esperable.

El producto por escalares de define como:
\[ c (∑_{i = 1}^n c_i w_i) = (∑_{i = 1}^n c c_i w_i) \]

El producto entre elementos de $R⟨X⟩$ se define como:
\[ (∑_{i = 1}^n c_i w_i) · (∑_{i = 1}^m c'_i w'_i) = ∑_{i = 1}^n ∑_{j = 1}^m c_i c'_j w_i w'_j \]

A los elementos de $R⟨X⟩$ se los llama polinomios no conmutativos.
% Esta definición creo que hay que mejorarla, pero no se como
\end{definition}

Algunos ejemplos de polinomios no conmutativos sobre $ℚ⟨\{a, b, c\}⟩$ son los siguientes:
\[ p_0 = a \]
\[ p_1 = ab + cb \]
\[ p_2 = 3 abb + 4 bcca - 2 acab \]

Notar que $p_1 ≠ ab + bc$ ya que el producto es no conmutativo.

Sobre los polinomios no conmutativos se hacen las siguientes definiciones:

\begin{definition}
Sean $R$ un anillo conmutativo, $p ∈ R⟨X⟩$, $c_1, …, c_n ∈ R$, $w_1, …, w_n, w ∈ ⟨X⟩$, $f = ∑_{i = 1}^n c_i w_i$ y $≤$ un buen orden monomial.
\begin{itemize}
\item $f_w = \left\{\begin{array}{ll} w = w_i → c_i \\ \text{si no} → 0  \end{array} \right.$
\item $\sop(f) = \{w_1, …, w_n\}$
\item $\lm_≤(f) = \min_≤(\sop(f))$
\item $\lc_≤(f) = f_{\lm(f)}$
\item $\lt_≤(f) = \lc_≤(f) · \lm_≤(f)$
\item $\tail_≤(f) = f - \lt_≤(f)$
\item $f$ es mónico $⇔ \lc_≤(f) = 1$
\end{itemize}

A $\sop(f)$ se lo llama soporte de $f$, a $\lm_≤(f)$ se lo llama monomio principal de $f$, a $\lc_≤(f)$ se lo llama coeficiente principal de $f$ y a $\lt_≤(f)$ se lo llama término principal de $f$. Los nombres lm, lc, lt y tail vienen del inglés leading monomial, leading coefficient, leading term y tail respectivamente.

\end{definition}

\begin{theorem}
Sea $R$ un anillo conmutativo, entonces:
\[ (R⟨X⟩, +, ·)\text{ es un anillo} \]
\end{theorem}

Esto significa que aplican todas las definiciones y teoremas de anillo.
En particular vale la definición de ideal y algunas definiciones y teoremas relacionados, que como son muy importantes para este trabajo las repasaremos a continuación.

\begin{definition}\label{def:ideal}
Sean $R$ un anillo e $I, B ⊆ R$, definimos que $I$ es un ideal de $R$ si y solo si:
\begin{enumerate}
\item $I ≠ ∅$

\item $∀a, b ∈ I : a + b ∈ I$

\item $∀a ∈ I, r, r' ∈ R : r a r' ∈ I$
\end{enumerate}

\[ (B) = \{∑_{i = 1}^n c_i b_i c_i' : n ∈ ℕ, b_1, …, b_n ∈ B, c_1, …, c_n, c_1', …, c_n' ∈ R\} \]
\end{definition}

\begin{theorem}
Sean $R$ un anillo y $B ⊆ R$, entonces:
\[ (B)\text{ es un ideal de }R \]

\end{theorem}

Además a $(B)$ se lo llama el ideal generado por $B$.

\begin{definition}[Congruencia modulo un ideal]\label{def:congruencia mod ideal}
Sean $R$ un anillo e $I ⊆ R$, se define $≡_I$ como relación en $R$ así:
\[ a ≡_I b ⇔ a - b ∈ I \]
\end{definition}

\begin{theorem}\label{thm:congruencia mod ideal es equivalencia}
Sean $R$ un anillo y $I ⊆ R$ un ideal, entonces:
\[ ≡_I \text{es una relación de equivalencia} \]
\end{theorem}

\begin{theorem}\label{thm:en ideal ⇔ congruente 0}
Sean $R$ un anillo, $I ⊆ R$ un ideal y $a ∈ R$, entonces:
\[ a ∈ I ⇔ a ≡_I 0 \]
\end{theorem}

Ahora volvemos al álgebra libre y a partir de ahora fijamos un cuerpo $K$.

Una pregunta que surge es dado un conjunto finito $F ⊆ K⟨X⟩$ y un elemento $f ∈ K⟨X⟩$, ¿se puede calcular si $f ∈ (F)$?

La respuesta a esa pregunta es que no, porque el problema es indecible. Sin embargo, si existen algoritmos que cuando $f ∈ (F)$ termina y devuelve una prueba, pero que cuando $f ∉ (F)$ puede no terminar. Sobre esos algoritmos se trata este trabajo.

Mas adelante va a ser necesario comparar no solo monomios si no también polinomios, así que $≤$ se extiende a $K⟨X⟩$ así:

\begin{definition}
Sean $f, g ∈  K⟨X⟩$, definimos que $f < g$ si y solo si vale alguna de las siguientes:
\begin{enumerate}
\item $f = 0 ∧ g ≠ 0$
\item $\lm_≤(f) < \lm_≤(g)$
\item $\lm(f) = \lm(g) ∧ \tail(f) < \tail(g)$
\end{enumerate}
Y $f ≤ g$ si y solo si $f < g ∨ f = g$.
\end{definition}

Es decir, el orden en los polinomios es orden lexicográfico con el polinomio visto como una lista de monomios, sin coeficientes ordenada de mayor a menor.

Por ejemplo, tenemos estas desigualdades en $K⟨X⟩$:
\[ a < ab \]
\[ bcc + c < bcc + abb \]
\[ ac < ac + aa \]

Ahora algunos teoremas sobre el orden de los polinomios.

\begin{theorem} La relación $<$ en $K⟨X⟩$ es un pre-orden.
\end{theorem}

\begin{theorem}\label{thm:≤ en KX no cadenas dec inf}
La relación $≤$ en $K⟨X⟩$ no tiene cadenas estrictamente decrecientes infinitas.
\end{theorem}
\begin{proof}
Supongamos que existen cadenas estrictamente decreciente infinita. Tomemos una $P$ que minimize $\lm(P_1)$. Tomar este mínimo es posible por el \cref{thm:≤ no cadenas dec inf}

Notar que:

\begin{fact}\label{fact:≤ en KX no cadenas dec inf:1} % Nombres de labels provisorios
$∀i ∈ ℕ : \lm(P_i) = \lm(P_1)$
\end{fact}
En efecto, no puede ser $\lm(P_i) < \lm(P_1)$ porque entonces $P_i, P_{i + 1}, …$ sería una cadena estrictamente decreciente infinita que rompería la minimalidad de $\lm(P_1)$ y no puede ser $\lm(P_i) > \lm(P_1)$ porque $P$ es una cadena estrictamente decreciente.

\begin{fact}\label{fact:≤ en KX no cadenas dec inf:2}
$\tail(P_1), \tail(P_2), …$ es una cadena estrictamente decreciente infinita.
\end{fact}
Esto vale por aplicar la definición del orden polinomial, por la \cref{fact:≤ en KX no cadenas dec inf:1} y por lo que estamos suponiendo sobre $P$.

Como claramente $0$ es un mínimo:

\begin{fact}\label{fact:≤ en KX no cadenas dec inf:3}
$P_1 ≠ 0$.
\end{fact}

Sin embargo, la \cref{fact:≤ en KX no cadenas dec inf:2} contradice la minimalidad de $\lm(P_1)$ ya que por la \cref{fact:≤ en KX no cadenas dec inf:3} vale que $\lm(\tail(P_1)) < \lm(P_1)$.

\end{proof}

\begin{definition}
Sean $F ⊆ K⟨X⟩$, $g ∈ K⟨X⟩ - \{0\}$, $a, b ∈ ⟨X⟩$ y $f, f' ∈ K⟨X⟩$:
\begin{itemize}
\item $f →_{≤, a, g, b} f' ⇔ \lm_≤(agb) ∈ \sop(f) ∧ f' = f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb$
\item $→_{≤, g} = ⋃_{a, b ∈ ⟨X⟩} →_{≤, a, g, b}$
\item $→_{≤, F} = ⋃_{g ∈ F} →_{≤, g}$
\end{itemize}
\end{definition}

\begin{theorem}[Las reducciones achican]\label{thm:→ achican}
Sean $F ⊆ K⟨X⟩$, $g ∈ K⟨X⟩ - \{0\}$, $a, b ∈ ⟨X⟩$ y $f, f' ∈ K⟨X⟩$, entonces:
\begin{enumerate}
\item $f →_{≤, a, g, b} f' ⇒ f' < f$

\item $f →_{≤, g} f' ⇒ f' < f$

\item $f →_{≤, F} f' ⇒ f' < f$
\end{enumerate}
\end{theorem}
\begin{proof}
Por definición de las reducciones tenemos que (1) $⇒$ (2) $⇒$ (3), por lo cual alcanza con probar (1). Para ello supongamos el antecedente $f →_{≤, a, g, b} f'$

Esto implica por definición de reducciones:
\begin{enumerate}
\setcounter{enumi}{3}
\item $\lm_≤(agb) ∈ \sop(f)$
\item $f' = f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb$
\end{enumerate}

Escribamos $f = ∑_{i = 1}^n c_i m_i$ con $c_1, …, c_n ∈ K$, $m_1, …, m_n ∈ ⟨X⟩, m_1 > m_2 > … > m_n$

Sea $i$ tal que $m_i = \lm_≤(agb)$, el cual existe por (4).

\begin{fact}\label{fact:→ achican:3}
Notar también que $m_i = \lm_≤(\frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb)$ porque es multiplicar por un escalar adentro del $\lm$ en la condición de $i$.
\end{fact}
\begin{description}
\item[Si $i ≠ 0$] La \cref{fact:→ achican:3} significa que los términos $c_1 m_1, c_2 m_2, …, c_{i-1}, m_{i-1}$ son iguales en $f$ y en $f'$ y no hay nada mas en el medio, porque $f'$ es $f$ con cosas menores o iguales a $\lm_≤(\frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb)$ restadas (por (5)).

Además, como $m_i = \lm_≤(\frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb)$, tenemos que $f'_{m_i} = 0$, por ende, el término que sigue después de $m_{i-1}$ (si es que hay) es menor que $m_i$ y por ende menor que $f$.

\item[Si $i = 0$] aplica lo mismo pero directamente a $m_0$ solo que sin tener en cuenta los $m$ anteriores.
\end{description}

\end{proof}

\begin{theorem}\label{thm:suma →↓}
Sean $F ⊆ K⟨X⟩, f, f_0, f_1 ∈ K⟨X⟩$, entonces:
\[ f_0 →_{≤, F} f_1 ⇒ f_0 + f ↓_{≤, F} f_1 + f \]
\end{theorem}
\begin{proof}
Supongamos el antecedente $f_0 →_{≤, F} f_1$.

Sean $g ∈ F, a, b ∈ K⟨X⟩$ tales que $f_1 = f_0 - \frac{{f_0}_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb$, los cuales existen por el antecedente y por definición de $→_{≤, F}$.

Dividamos en casos según si $\lm_≤(agb) ∈ \sop(f)$:

\begin{description}
\item[Caso $\lm_≤(agb) ∉ \sop(f)$]\

En este caso tenemos $f_0 + f →_{≤, F} f_1 + f$ por tomar $g$, $a$ y $b$, y por ende tenemos $f_0 + f ↓_{≤, F} f_1 + f$

\item[Caso $\lm_≤(agb) ∈ \sop(f)$]\
\begin{description}
\item[Subcaso $f_{\lm_≤(agb)} = -{f_0}_{\lm_≤(agb)}$]

Este es el caso en el que $\lm_≤(agb)$ se cancela en la suma $f_0 + f$. Y como además $\lm_≤(agb) ∉ \sop(f_1)$ por el antecedente, tenemos:

\begin{DispWithArrows*}
&f_1 + f →_{≤, F} f_1 + f - \frac{f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \Arrow{Subcaso} \\
& ⇒ f_1 + f →_{≤, F} f_1 + f + \frac{{f_0}_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \Arrow{Condición de $g$, $a$ y $b$} \\
& ⇒ f_1 + f →_{≤, F} f_0 + f \\
& ⇒ f_1 + f ↓_{≤, F} f_0 + f
\end{DispWithArrows*}

\item[Subcaso $f_{\lm_≤(agb)} ≠ -{f_0}_{\lm_≤(agb)}$] En este caso $\lm_≤(agb)$ no se cancela en la suma $f_0 + f$, así que podemos aplicar $→_{≤, F}$:
\begin{DispWithArrows*}
&f_0 + f →_{≤, F} f_0 + f - \frac{(f_0 + f)_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \\
& ⇒ f_0 + f →_{≤, F} f_0 + f - \frac{{f_0}_{\lm_≤(agb)} + f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \\
& ⇒ f_0 + f →_{≤, F} f_0 + f - \frac{{f_0}_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb - \frac{f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \Arrow{Condición de $g$, $a$ y $b$}\\
& ⇒ f_0 + f →_{≤, F} f_1 + f - \frac{f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb
\end{DispWithArrows*}
  Llamemos (1) a este último resultado.

Además por el caso y por subcaso también tenemos $\lm_≤(agb) ∈ \sop(f_1 + f)$, así que tenemos:
\begin{DispWithArrows*}
&f_1 + f →_{≤, F} f_1 + f - \frac{(f_1 + f)_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \\
& ⇒ f_1 + f →_{≤, F} f_1 + f - \frac{{f_1}_{\lm_≤(agb)} + f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \Arrow{$\lm_≤(agb) ∉ \sop(f_1)$ porque $f_0 →_{≤, F} f_1$ y definición de $→_{≤, F}$}\\
& ⇒ f_1 + f →_{≤, F} f_1 + f - \frac{0 + f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb \\
& ⇒ f_1 + f →_{≤, F} f_1 + f - \frac{f_{\lm_≤(agb)}}{g_{\lm_≤(agb)}} agb
\end{DispWithArrows*}
  Llamemos (2) a este último resultado.

Por (1) y (2) tenemos $f_0 + f ↓_{≤, F} f_1 + f$
\end{description}
\end{description}
\end{proof}

\begin{theorem}[Clausura reflexo transitiva de las reducciones]\label{thm:→^* = ≡}
Sea $F ⊆ K⟨X⟩$, entonces:
\[ ↔^*_{≤, F} = ≡_{(F)} \]

(Donde $≡_{(F)}$ es la congruencia modulo un ideal definida en la \cref{def:congruencia mod ideal})
\end{theorem}
\begin{proof}
Lo vamos a probar por doble inclusión
\begin{description}

\item[Prueba de $↔^*_{≤, F} ⊆ ≡_{(F)}$] Como tanto $↔^*_{≤, F}$ como $≡_{(F)}$ son relaciones de equivalencia y además $↔^*_{≤, F}$ es la mínima relación de equivalencia que contiene a $→_{≤, F}$, alcanza con probar $→_{≤, F} ⊆ ≡_{(F)}$. Para eso supongamos $f →_{≤, F} f'$ y probemos $f ≡_{(F)} f'$.

Sean $g ∈ F, a, b ∈ ⟨X⟩$ tales que $f' = f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb$, los cuales existen por lo que estamos suponiendo y por la definición de $→_{≤, F}$. Tenemos:

\begin{DispWithArrows*}
&f ≡_{(F)} f' \\
& ⇔ f - f' ∈ (F) \\
& ⇔ f - (f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb) ∈ (F) \\
& ⇔ \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb ∈ (F)
\end{DispWithArrows*}
Y esto último es claramente cierto por la definición de ideal (\cref{def:ideal})

\item[Prueba de $≡_{(F)} ⊆ ↔^*_{≤, F}$] Supongamos $f ≡_{(F)} f'$ y probemos $f ↔^*_{≤, F} f'$.

Sean:
\begin{itemize}
\item $g = f - f'$.
\item $c_1, …, c_n, c_1', …, c_n' ∈ K⟨X⟩$, $g_1, …, g_n ∈ F$ tales que $g = ∑_{i = 1}^n c_i g_i c_i'$, los cuales existen porque por definición de $≡_·$ tenemos $g ∈ (F)$ y por definición de $(\ ·\ )$.
\item $f_0 = f$
\item Para cada $i ∈ \{1, …, n\}$: $f_i = f_{i - 1} - c_i g_i c_i'$.
\end{itemize}

Tenemos entonces:

\begin{DispWithArrows*}
&∀i ∈ \{1, …, n\} : g_i →_{≤, F} 0 \\
& ⇒ ∀i ∈ \{1, …, n\} : - c_i g_i c_i' →_{≤, F} 0 \Arrow{\cref{thm:suma →↓}} \\
& ⇒ ∀i ∈ \{1, …, n\} : f_{i - 1} ↓_{≤, F} f_i \\
& ⇒ ∀i ∈ \{1, …, n\} : f_{i - 1} ↔^*_{≤, F} f_i \\
& ⇒ f_0 ↔^*_{≤, F} f_n \Arrow{$f_n = f - g = f'$}\\
& ⇒ f ↔^*_{≤, F} f_n
\end{DispWithArrows*}

\end{description}
\end{proof}

\begin{theorem}[Las reducciones se mantienen en ideal]\label{thm:→ mantiene pertenencia a ideal}
Sean $F ⊆ K⟨X⟩, f, f' ∈ (F)$, entonces:
\[ f →^*_{≤, F} f' ⇒ (f ∈ (F) ⇔ f' ∈ (F)) \]
\end{theorem}
\begin{proof}
Si asumimos $f →^*_{≤, F} f'$ tenemos por el \cref{thm:→^* = ≡} $f ≡_{(F)} f'$ y entonces por el \cref{thm:en ideal ⇔ congruente 0} tenemos $f ∈ (F) ⇔ f' ∈ (F)$
\end{proof}

\begin{theorem}
Sea $F ⊆ K⟨X⟩$, entonces:
\begin{itemize}
\item $→_{≤, F}$ es terminante
\end{itemize}
\end{theorem}
\begin{proof} Lo vamos a demostrar por contradicción. Supongamos que $→_{≤, F}$ no es terminante, por definición de terminante podemos tomar una cadena $P ∈ K⟨X⟩^ℕ$ tal que:

$∀i ∈ ℕ : P_i →_{≤, F} P_{i+1}$

Por el \cref{thm:→ achican} tenemos que:

$∀i ∈ ℕ : P_i > P_{i+1}$

Pero esto contradice el \cref{thm:≤ en KX no cadenas dec inf} que dice que no hoy cadenas estrictamente decrecientes infinitas en $K⟨X⟩$.

\end{proof}

\begin{theorem}[Caracterización de las formas normales de $→$]
Sea $F ⊆ K⟨X⟩, f ∈ K⟨X⟩$, entonces: % Por algún motivo acá se pone solo un salto de linea extra
\[ f\text{ está en forma normal con respecto a} →_{≤, F} ⇔ ∄g ∈ F, m ∈ \sop(f) : \lm(g) | m \]
\end{theorem}
\begin{proof}
Por contradicción, supongamos que tenemos $g ∈ F, m ∈ \sop(f)$ tales que $\lm(g) ∈ \sop(f)$.

Sean $a, b ∈ ⟨X⟩$ tal que $m = agb$, los cuales existen por la definición de divisibilidad.

Entonces tenemos $f →_{≤, F} f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb$ y por ende $f$ no está en forma normal.

\end{proof}

Sin embargo $→_{≤, F}$ no necesariamente es confluente, eso motiva las siguientes dos definiciones.

\begin{definition}[Bases de Gröbner]\label{def:base de Gröbner}
Sean $I$ un ideal de $K⟨X⟩$ y $F ⊆ K⟨X⟩$:
\begin{itemize}
\item $F$ es una base de Gröbner de $I ⇔ (F) = I ∧ →_{≤, F}$ es confluente
\item $F$ es una base de Gröbner reducida de $I ⇔ F$ es una base de Gröbner de $I ∧ ∀g ∈ F : g$ es irreducible con respecto a $→_{≤, F - \{g\}}$
\end{itemize}
\end{definition}

\begin{definition}
Sea $e_≤ : 𝒫(K⟨X⟩) → K⟨X⟩ → K⟨X⟩$:
\begin{itemize}
\item $e_≤$ es una estrategia de reducción $⇔ ∀F ⊆ K⟨X⟩, f ∈ K⟨X⟩ : e_≤(F)(f)$ es forma normal de $f$ con respecto a $→_{≤, F}$
\end{itemize}
\end{definition}

En los casos en los que $F$ es una base de Gröbner y por ende $→_{≤, F}$ es confluente hay una sola $e_≤(F)$ posible, pero cuando no es confluente puede haber muchas. Tener definida la estrategia de reducción como una función nos va a venir bien mas adelante para hablar de una forma normal manteniendo la generalidad de como se calcula una forma normal de cada elemento.

Un ejemplo de estrategia de reducción podría calcularse con el siguiente seudocódigo:

\begin{algorithm}[H] % La H es para que se quede acá, porque se iba a otra página. Estaría bueno hacerlo global
  \caption{Ejemplo de estrategia de reducción}\label{alg:estrategia de reducción}
  \KwData{$F = \{f_1, …, f_n\} ⊆ K⟨X⟩, g ∈ K⟨X⟩$}
  \KwResult{$g' ∈ K⟨X⟩$}
  $g' ← g$

  $i ← 1$

  \While{$i ≤ n$} {
    \While{$i ≤ n$} {
      \If{$f_i ∈ \sop(g')$} {
        $g' ← g' - \frac{g'_{\lm(f_i)}}{\lc(f_i)}f_i$

        $i ← 1$

        \Break
      }
      \Else{
        $i ← i + 1$
      }
    }
  }
  \Return{$g'$}
\end{algorithm}

Este algoritmo consiste básicamente en siempre buscar entre los elementos de $G$ si hay alguno con el que reducir, y parar cuando ya no hay ninguno.

Una propiedad sobre las estrategias de reducción que vamos a necesitar es la siguiente:

\begin{theorem}[Las estrategias de reducción mantienen la pertenencia a ideales]\label{thm:e mantiene pertenencia a ideal}
Sean $e_≤$ una estrategia de reducción, $F ⊆ K⟨X⟩$ y $f ∈ (F)$, entonces:
\[ e_≤(F)(f) ∈ (F) \]
\end{theorem}
\begin{proof}
Como $e_≤(F)(f)$ es una forma normal de $f$ tenemos $f →^*_{≤, F} e_≤(F)(f)$ y por ende por el \cref{thm:S es cerrado en ideal} y que $F ⊆ K⟨X⟩$ tenemos $e_≤(F)(f) ∈ (F)$.
\end{proof}

\begin{theorem}\label{thm:equivalencias de base de Gröbner}
Sean $I$ un ideal de $K⟨X⟩$ y $G ⊆ K⟨X⟩$. Las siguientes afirmaciones son equivalentes:
\begin{enumerate}
\item $G$ es una base de Gröbner de $I$

\item $∀f ∈ K⟨X⟩ : (f ∈ I ⇔ f →^*_{≤, G} 0)$

\item $∀f ∈ K⟨X⟩ : (f ∈ I ⇒ f →^*_{≤, G} 0)$

\item $(G) = I ∧ ∀f ∈ I : ∃g ∈ G : \lm(g) | \lm(f)$

\item $∀f ∈ I - \{0\} : ∃g_1, …, g_n ∈ G, a_1, …, a_n, b_1, …, b_n ∈ ⟨X⟩ : \lm(a_i g_i b_i) ≤ \lm(f) : f = ∑_{i = 1}^n a_i g_i b_i$
\end{enumerate}
% Quizás agregue mas en algún momento

\end{theorem}
\begin{proof} Vamos a probar (1) $⇒$ (2), (2) $⇒$ (1), (2) $⇔$ (3), (2) $⇒$ (4), (4) $⇒$ (3), (2) $⇒$ (5) y (5) $⇒$ (4).
\begin{description}

\item[(1) $⇒$ (2)] Supongamos que $G$ es una base de Gröbner de $I$ y tomemos $f ∈ K⟨X⟩$. Tenemos que probar $f ∈ I ⇔ f →^*_{≤, G} 0$. Vamos de un lado para el otro:

\begin{DispWithArrows*}
&f ∈ I \Arrow{\cref{thm:en ideal ⇔ congruente 0}} \\
& ⇔ f ≡_I 0 \Arrow{\cref{thm:→^* = ≡}} \\
& ⇔ f ↔^*_{≤, G} 0 \Arrow{Al ser $G$ una base de Gröbner $→_{≤, G}$ es confluente y por ende por el \cref{thm:confluente ⇔ Church-Rosser} es Church-Rosser, así que aplico el sii de Church-Rosser} \\
& ⇔ f ↓_{≤, G} 0 \Arrow{Definición de $↓$} \\
& ⇔ ∃f' ∈ K⟨X⟩ : f →^*_{≤, G} f' ∧ 0 →^*_{≤, G} f' \Arrow{Como $0$ es el mínimo elemento y el \cref{thm:→ achican} dice que las reducciones achican el segundo término del $∧$ ocurre solo para $f' = 0$} \\
& ⇔ f →^*_{≤, G} 0
\end{DispWithArrows*}

\item[(2) $⇒$ (1)]
Supongamos (2), o sea $∀f ∈ K⟨X⟩ : (f ∈ I ⇔ f →^*_{≤, G} 0)$. Tenemos que probar que $G$ es una base de Gröbner de $I$, es decir $(G) = I ∧ →_{≤, G}$ es confluente.

Probemos cada termino del $∧$ por separado:

\begin{description}
\item[Prueba de $(G) = I$] Tomemos $f ∈ K⟨X⟩$ y probemos $f ∈ (G) ⇔ f ∈ I$, probando ida y vuelta por separado:

\begin{description}
\item[Ida ($⇒$)] Supongamos antecedente $f ∈ (G)$.

Sean $c_1, …, c_n, c_1', …, c_n' ∈ K⟨X⟩$, $g_1, …, g_n ∈ G$ tales que $f = ∑_{i = 1}^n c_i g_i c_i'$, los cuales existen por la definición de $(\ ·\ )$.

Definamos $f_0 = f$ y para $i ∈ \{1, …, n\}$ $f_i = f_{i-1} - c_i g_i c_i'$.

Notar que tenemos $∀i ∈ \{1, …, n\} : f_{i-1} →_{≤, G} f_i$ y que $f_n = 0$.

Esto significa que $f →^*_{≤, G} 0$ y por ende por (2) vale $f ∈ I$.

\item[Vuelta ($⇐$)] Supongamos el antecedente $f ∈ I$.

Por (2) tenemos que $f →^*_{≤, G} 0$

Así que sean $f_0, f_1, …, f_n ∈ K⟨X⟩$ tales que $f_0 = f$, $f_n = 0$ y $∀i ∈ \{1, …, n\} : f_{i-1} →_{≤, G} f_i$, los cuales existen por la definición de $^*$.

Además, para cada $i ∈ \{1, …, n\}$ sean $c_i, c_i' ∈ K⟨X⟩, g_i ∈ G$ tales que $f_i = f_{i-1} - c_i g_i c_i'$, los cuales existen por definición de $→_{≤, G}$.

Notar que en particular $f_{i-1} = f_i + c_i g_i c_i'$ y por ende $f = ∑_{i = 1}^n c_i g_i c_i'$, lo cual prueba que $f ∈ (G)$.

\end{description}

\item[Prueba de $→_{≤, G}\text{ es confluente}$]\

Por definición de confluencia alcanza que probar $∀f, f_0, f_1 ∈ K⟨X⟩ : f →^*_{≤, G} f_0 ∧ f →^*_{≤, G} f_1 ⇒ f_0 ↓_{≤, G} f_1$.

Así que tomemos $f, f_0, f_1 ∈ K⟨X⟩$ y probemos el implica yendo de un lado para el otro.
\begin{DispWithArrows*}
&f →^*_{≤, G} f_0 ∧ f →^*_{≤, G} f_1 \\
& ⇒ f_0 ↔^*_{≤, G} f_1 \Arrow{\cref{thm:→^* = ≡}} \\
& ⇒ f_0 ≡_{(G)} f_1 \Arrow{Definición $≡_{\ ·\ }$} \\
& ⇒ f_0 - f_1 ∈ (G) \Arrow{(6), ya probamos que $(G) = I$} \\
& ⇒ f_0 - f_1 →^*_{≤, G} 0 \Arrow{\cref{thm:suma →↓}} \\
& ⇒ (f_0 - f_1) + f_1 ↓_{≤, G} 0 + f_1 \\
& ⇒ f_0 ↓_{≤, G} f_1
\end{DispWithArrows*}
\end{description}

\item[(2) $⇔$ (3)] La ida es claramente cierta y la vuelta $f ∈ I ⇐ f →^*_{≤, G} 0$ es cierta por el \cref{thm:→^* = ≡}.

\item[(2) $⇒$ (4)] Supongamos (2).

La parte de $(G) = I$ es valida porque (2) $⇒$ (1) y $(G) = I$ es parte de la definición de base de Gröbner.

Para la parte de $∀f ∈ I : ∃g ∈ G : \lm(g) | \lm(f)$ tomemos $f ∈ I$ y mostremos un $g$ que cumple el $∃$:

Por (2) tenemos $f →^*_{≤, G} 0$, esto significa que en alguno de los pasos de el $→^*_{≤, G}$ se tiene que reducir el monomio principal de $f$, o sea, uno de los pasos es de la forma $→_{≤, a, g, b}$ tal que $a \lm(g) b = \lm(f)$ con $g ∈ G, a, b ∈ ⟨X⟩$, por lo tanto, tenemos que $\lm(g) | \lm(f)$.

\item[(4) $⇒$ (3)] Lo probamos por contradicción, o sea, supongamos que vale (4) y que no vale (3). En particular tomemos el mínimo $f$ tal que $f ∈ I$ pero no se cumple que $f →^*_{≤, G} 0$.

Por (4) sea $g ∈ G$ tal que $\lm(g) | \lm(f)$ y sean también:
\begin{itemize}
\item $a, b ∈ ⟨X⟩$ tales que $a \lm(g) b = \lm(f)$
\item $f' = f - \frac{f_{\lm_≤(agb)}}{\lc_≤(g)}agb$
\end{itemize}

Notar que $f' ∈ I$ ya que $f ∈ I$ y $g ∈ (G) = I$ y notar que $f →_{≤, G} f'$.

Además por \cref{thm:→ achican} $f' < f$.

Y como no vale $f →^*_{≤, G} 0$ tampoco puede valer $f' →^*_{≤, G} 0$, sin embargo esto contradice que $f$ sea mínimo.

\item Los casos (2) $⇒$ (5) y (5) $⇒$ (4) son muy fáciles y quedan como ejercicio. % Pongo esto hasta que la haga

\end{description}
Con esto se termina la prueba.
\end{proof}


\section{Algoritmo de Buchberger}

\begin{definition}
Sean $p, q, a, b, c, d ∈ ⟨X⟩$
\[ (a, b, c, d, p, q)\text{ es una ambigüedad} ⇔ apb = cqd ∧ |a|, |b| < |q| ∧ |c|, |d| < |p| \]

La ambigüedad $(a, b, c, d, p, q)$ se dice que es:
\begin{itemize}
\item De superposición $⇔ a = ε = d ∨ b = ε = c$
\item De inclusión $⇔ a = ε = b ∨ c = ε = d$
\item Relevante $⇔$ es de superposición o de inclusión
\end{itemize}

Además, si $f, g ∈ K⟨X⟩$ se dice que $(a, b, c, d, f, g)$ es una ambigüedad si y solo si $(a, b, c, d, \lm_≤{(f)}, \lm_≤{(g)})$ es una ambigüedad y lo mismo para ambigüedades de superposición, de inclusión y relevantes.

Sea además $F ⊆ K⟨X⟩$:
\begin{itemize}
\item $\amb(f, g) = \{(a, b, c, d, f, g) : a, b, c, d ∈ ⟨X⟩ ∧ (a, b, c, d, f, g)\text{ es una ambigüedad}\}$
\item $\amb(F) = ⋃_{f, g ∈ F - \{0\}}{\amb(f, g)}$
\end{itemize}

\end{definition}

\begin{theorem}
Sean $a, b, c, d ∈ ⟨X⟩$ y $f, g ∈ K⟨X⟩$ entonces si $α = (a, b, c, d, f, g)$ es una ambigüedad tenemos que:
\[ \lm_≤{(afb)} = \lm_≤{(cgd)} \]

\end{theorem}
\begin{proof}\
\begin{DispWithArrows*}
&\lm_≤{(afb)} \Arrow{Definición de ambigüedad para polinomios} \\
& = a\lm_≤{(f)}b \Arrow{Definición de ambigüedad} \\
& = c\lm_≤{(g)}d \Arrow{Definición de ambigüedad para polinomios} \\
& = \lm_≤{(cgd)}
\end{DispWithArrows*}
\end{proof}

Eso motiva la siguiente definición.

\begin{definition}[Monomios principales de ambigüedades]
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩$ y $α = (a, b, c, d, f, g)$ una ambigüedad.
\[ \lm_≤{(α)} = \lm_≤{(afb)} \]
\end{definition}

Notar que también $\lm_≤{(α)} = \lm_≤{(cgb)}$

\begin{definition}[S-polinomios]
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩$ y $α = (a, b, c, d, f, g)$ una ambigüedad.
\[ \S(α) = \frac{afb}{\lc_≤{(f)}} - \frac{cgd}{\lc_≤{(g)}} \]
\end{definition}

\begin{theorem}
Sean $a, b, c, d ∈ ⟨X⟩, f, g ∈ K⟨X⟩$ y $α = (a, b, c, d, f, g)$ una ambigüedad, entonces:
\[ \lm_≤{(\S(α))} < \lm_≤{(α)} \]
\end{theorem}
\begin{proof}
Esto es porque en la resta $\frac{afb}{\lc_≤{(f)}} - \frac{cgd}{\lc_≤{(g)}}$ los monomios principales se cancelan.
\end{proof}

\begin{theorem}\label{thm:S es cerrado en ideal}
Sean $I ⊆ K⟨X⟩$ un ideal $a, b, c, d ∈ ⟨X⟩, f, g ∈ I$ y $α = (a, b, c, d, f, g)$ una ambigüedad, entonces:
\[ \S(α) ∈ I \]
\end{theorem}
\begin{proof}
En la definición de $\S$ se ve claramente que es una combinación lineal de $f$ y $g$ con elementos de $K⟨X⟩$ (en particular con los elementos $\frac{a}{\lc_≤{(f)}}$, $b$, $\frac{c}{\lc_≤{(g)}}$ y $d$)
\end{proof}

\begin{theorem}\label{thm:equivalencias de base de Gröbner (con ambs)}
Sean $I$ un ideal de $K⟨X⟩$ y $G ⊆ K⟨X⟩$.

Son equivalentes:
\begin{enumerate}
\item $G$ es una base de Gröbner de $I$

\item $∀α ∈ \amb(G) : \S(α) →^*_{≤, G} 0$

\end{enumerate}
\end{theorem}
% TODO: Agregar prueba. De cualquier manera, Hof no lo prueba a esto

% Agregar algunos teoremas sobre S polinomios, ambigüedades, y bases de Gröbner

\begin{definition}[Conjuntos del algoritmo de Buchberger]
Sean $F ⊆ K⟨X⟩$ y $e_≤$ una estrategia de reducción:
\begin{itemize}
\item $\B_{e_≤}^0(F) = F$
\item $\B_{e_≤}^{i + 1}(F) = \B_{e_≤}^i(F) ∪ \{e_≤(\B_{e_≤}^i(F))(\S(α)) : α ∈ \amb(\B_{e_≤}^i(F))\}$
\item $\B_{e_≤}(F) = ⋃_{i = 0}^∞ \B_{e_≤}^i(F)$
\end{itemize}
\end{definition}

Estos conjuntos forman esencialmente el algoritmo de Buchberger. Para probar la correctitud vamos a querer probar esto:

\begin{theorem}\label{thm:Buchberger correctitud}
Sean $F ⊆ K⟨X⟩$ y $e_≤$ una estrategia de reducción, entonces:
\begin{enumerate}
\item $\B_{e_≤}(F)$ es una base de Gröbner de $(F)$
\item $(F)$ tiene una base de Gröbner finita $⇒ ∃i ∈ ℕ : (\B_{e_≤}^i(F))$ es una base de Gröbner
\end{enumerate}
\end{theorem}

Pero para probar eso primero vamos a probar algunos lemas en el contexto de este teorema.

\begin{lemma}\label{lemma:Buchberger correctitud:3}
$∀i ∈ ℕ : \B_{e_≤}^{i}(F) ⊆ (F)$
\end{lemma}
\begin{proof}
Por inducción en $i$ el caso base es valido porque $F ⊆ (F)$, para el caso inductivo supongamos que vale para $i$ y probemos que vale para $i + 1$:

Tomemos $f ∈ \B_{e_≤}^{i + 1}(F)$ y probemos que $f ∈ (F)$.

Por la definición recursiva de $\B_{e_≤}^{i + 1}$ tenemos $f ∈ \B_{e_≤}^i(F) ∨ ∃α ∈ \amb(\B_{e_≤}^i(F)) : f = e_≤(\B_{e_≤}^i(F))(\S(α))$.

El caso $f ∈ \B_{e_≤}^i(F)$ es valido por hipótesis inductiva. Para el otro caso tomemos ese $α$.

Por el \cref{thm:S es cerrado en ideal} tenemos que $\S(α) ∈ \B_{e_≤}^i(F)$ y por la hipótesis inductiva que $\S(α) ∈ (F)$.

Esto implica por el \cref{thm:e mantiene pertenencia a ideal} que $e_≤(\B_{e_≤}^i(F))(\S(α)) ∈ \B_{e_≤}^i(F)$ y por la hipótesis inductiva que $e_≤(\B_{e_≤}^i(F))(\S(α)) ∈ (F)$.
\end{proof}

\begin{lemma}\label{lemma:Buchberger correctitud:4}
$∀i ∈ ℕ : \B_{e_≤}(F) ⊆ (F)$
\end{lemma}
\begin{proof}
Esto es consecuencia directa de la \cref{lemma:Buchberger correctitud:3} y la definición de $\B_{e_≤}$.
\end{proof}

\begin{lemma}\label{lemma:Buchberger correctitud:5}
$(\B_{e_≤}(F)) = (F)$
\end{lemma}
\begin{proof}
Esto vale porque por el caso base de la definición de $\B_{e_≤}^i$ tenemos $F ⊆ \B_{e_≤}$ y por la \cref{lemma:Buchberger correctitud:4}.
\end{proof}

\begin{lemma}\label{lemma:Buchberger correctitud:6}
$∀α ∈ \amb(\B_{e_≤}(F)) : \S(α) →^*_{≤, \B_{e_≤}(F)} 0$
\end{lemma}
\begin{proof}
Tomemos $α = (a, b, c, d, f, g) ∈ \amb(\B_{e_≤}(F))$ y probemos el $∀$.

Por definición de $\amb$ vale que $f, g ∈ \B_{e_≤}(F)$, así que sea $i ∈ ℕ$ el mínimo tal que $f ∈ \B_{e_≤}^i(F)$, $j ∈ ℕ$ el mínimo tal que $g ∈ \B_{e_≤}^j(F)$ y $k = \max(i, j)$.

Notar que $α ∈ \amb(\B_{e_≤}^k(F))$ por la definición de $\amb$ y por ende $\S(α) ∈ \B_{e_≤}(F)$.

Por definición de $→^*_{≤, F}$ esto significa que $\S(α) →^*_{≤, \B_{e_≤}(F)} 0$, así que queda probada la afirmación.
\end{proof}

\begin{proof}[Demostración del \cref{thm:Buchberger correctitud}]
Por el \cref{lemma:Buchberger correctitud:5} y el \cref{lemma:Buchberger correctitud:6} vale la equivalencia de base de Gröbner del \cref{thm:equivalencias de base de Gröbner (con ambs)}, así que (1) queda probado.

Ahora para probar (2) supongamos el antecedente y tomemos $G = \{g_1, …, g_n\}$ una base de Gröbner finita de $(F)$.

Para cada $i ∈ \{1, …, n\}$ sean:
\begin{itemize}
\item $g_{i, 1}, …, g_{i, k_i} ∈ \B_{e_≤}(F), a_{i, 1}, …, a_{i, k_i}, b_{i, 1}, …, b_{i, k_i} ∈ ⟨X⟩$ con $\lm(a_{i, j} g_{i, j} n_{i, j}) ≤ \lm(g_i)$ tales que $g_i = ∑_{j = 1}^{k_i} a_{i, j} g_{i, j} b_{i, j}$

Los cuales existen por (1) y por (5) del \cref{thm:equivalencias de base de Gröbner}.

\item $F' = \{g_{i, j} : i ∈ \{1, …, n\}, j ∈ \{1, …, k_i\}\}$

\item $k ∈ ℕ$ el mínimo tal que $F' ⊆ \B_{e_≤}^k(F)$

Notar que $k$ está bien definido porque $F'$ es finito.
\end{itemize}

Ahora vamos a probar que $\B_{e_≤}^k(F)$ es una base de Gröbner de $(F)$.

Por (5) del \cref{thm:equivalencias de base de Gröbner} alcanza con probar:

\[ ∀f ∈ (F) - \{0\} : ∃g_1, …, g_n ∈ \B_{e_≤}^k(F), a_1, …, a_n, b_1, …, b_n ∈ ⟨X⟩ : \lm(a_i g_i b_i) ≤ \lm(f) : f = ∑_{i = 1}^n a_i g_i b_i \]

Tomemos $f' ∈ (F) - \{0\}$ y escribamoslo de esa forma:

Por (5) del \cref{thm:equivalencias de base de Gröbner} sean $i'_1, …, i'_{n'} ∈ G, a'_1, …, a'_{n'}, b'_1, …, b'_{n'} ∈ ⟨X⟩$ tales que $\lm(a'_i g_{i'_i} b'_i) ≤ \lm(f')$ y $f' = ∑_{i = 1}^{n'} a'_i g_{i'_i} b'_i$

\begin{DispWithArrows*}
&f' = ∑_{i = 1}^{n'} a'_i g_{i'_i} b'_i \Arrow{Condición de $g_{i, j}$} \\
& = ∑_{i = 1}^{n'} a'_i (∑_{j = 1}^{k_{i'_i}} a_{i', j} g_{i, j} b_{i', j}) b'_i \\
& = ∑_{i = 1}^{n'} ∑_{j = 1}^{k_i'} a'_i a_{i', j} g_{i, j} b_{i', j} b'_i
\end{DispWithArrows*}

Sabemos además que $g_{i',j} ∈ \B_{e_≤}^k(F)$ y que $g_{i', j} ≤ g_{i'_i} ≤ f'$.

Con esto queda completada la prueba.

\end{proof}

La definición de esos conjuntos nos da de forma directa un algoritmo para calcular bases de Gröbner:

\begin{algorithm}[H] % La H es para que se quede acá, porque se iba a otra página. Estaría bueno hacerlo global
  \caption{Algoritmo de Buchberger}\label{alg:Buchberger}
  \KwData{$F ⊆ K⟨X⟩$, $e_≤$ una estrategia de reducción}
  \KwResult{$G ⊆ K⟨X⟩$ una base de Gröbner de $(F)$ si es que termina}
  $G ← F$

  \Loop{} {
    $ambs ← \amb(G)$

    $new\_G ← G$

    \For{$α ∈ ambs$} {
      $f ← e_≤(G)(\S(α))$

      \If{$f ≠ 0$} {
        $new\_G ← new\_G ∪ \{f\}$
      }
    }

    \If{$new\_G = G$} {
      \Break
    }

    $G ← new\_G$
  }
  \Return{$G$}
\end{algorithm}

El algoritmo así, si bien es una implementación tal cual de la definición de los conjuntos $\B_{e_≤}^i$ que probamos que es correcta, es muy lenta y necesita un cambio para que pase a andar bien.

Ese cambio es en lugar de para las reducciones usar el conjunto anterior usar también los nuevos polinomios que ya fueron agregados, es decir, llamar a $e_≤$ con $new\_G$ en lugar de con $G$. Esto lo podemos implementar así:

\begin{algorithm}[H] % La H es para que se quede acá, porque se iba a otra página. Estaría bueno hacerlo global
  \caption{Primera optimización de Buchberger}\label{alg:Buchberger optimización 1}
  \KwData{$F ⊆ K⟨X⟩$, $e_≤$ una estrategia de reducción}
  \KwResult{$G ⊆ K⟨X⟩$ una base de Gröbner de $(F)$ si es que termina}
  $G ← F$

  $ambs ← \amb(G)$

  \While{$ambs ≠ ∅$} {
    elegir $α ∈ ambs$

    $ambs ← ambs - \{α\}$

    $f ← e_≤(G)(\S(α))$

    \If{$f ≠ 0$} {
      $G ← G ∪ \{f\}$
    }
  }

  \Return{$G$}
\end{algorithm}

Ese cambio hace que pase de no andar rápido casi nunca a andar rápido en un montón de casos.

En ese seudocódigo no está aclarado como se elige una ambigüedad, pero las dos formas que mejor andan son elegir la de menor S-polinomio y elegir la que hace mas tiempo está en el conjunto de ambigüedades (first in first out).

\chapter{Implementación}

En este capitulo se explican los detalles de como está hecha la implementación.

\section{Monomios}

Para los monomios, o sea los elementos de $⟨X⟩$, la base de la implementación es así:

\begin{lstlisting}[language=C++]
  struct Monomial {
    typedef __uint8_t X;
    vector<X> vals;
  };
\end{lstlisting}

El tipo \texttt{Monomial::X} es el tipo en el que se guardan las variables, con el código así como está son números de 8 bits, por lo cual puede haber hasta 256 variables, si fuera necesario usar mas variables hay que cambiarlo por un tipo mas grande como \texttt{\_\_uint16\_t}. Se podría haber usado un argument de template para que se pueda cambiar sin tener que cambiar el código, pero no está hecho para simplificar el código, ya que para los polinomios ya hay dos argumentos de template.

Este struct tiene implementada las operaciones básicas con monomios incluyendo el producto, métodos para saber divisibilidad de monomios y dividir monomios tanto obteniendo todas las respuestas como obteniendo una respuesta y métodos para leer e imprimir monomios tanto de forma bonita como se los suele escribir (para monomios que tienen variables menores a 26) como en un formato fácil de leer desde otro código.

El formato fácil de leer desde código consiste en un número entero no negativo $n$ seguido de $n$ números $x_1$, …, $x_n$ que son los números de variables. Cuando $n = 0$ no hay ningún $x_i$. Se puede representar así el formato:

\begin{lstlisting}[escapechar=+]
  +$n$+ +$x_1$+ … +$x_n$+
\end{lstlisting}

\section{Orden monomial}

El único orden monomial que está implementado es el orden lexicográfico por grado y está implementado así:

\begin{lstlisting}[language=C++]
  struct DegLexOrd {
    bool operator()(const Monomial& a, const Monomial& b) const {
      size_t n = a.vals.size(), m = b.vals.size();
      return n < m || (n == m && a.vals < b.vals);
    }
  };
\end{lstlisting}

Esto está definido a parte y no como definir el operador \texttt{<=} para \texttt{Monomial} por si se quiere usar otro orden monomial.

\section{Polinomios}

Para los polinomios, o sea los elementos de $K⟨X⟩$, la base de la implementación es así:

\begin{lstlisting}[language=C++]
  template<typename K, class ord = DegLexOrd>
  struct Poly {
    vector<pair<Monomial, K>> terms;
  };
\end{lstlisting}

El parámetro de template \texttt{K} es el cuerpo de los coeficientes, por lo general los racionales o la aritmética módulo algún primo y el parámetro de template \texttt{ord} es el orden monomial que se va a usar, por defecto es el orden lexicográfico por grado.

\texttt{K} tiene que tener implementada todas las operaciones de cuerpo y un constructor que pueda tomar un \texttt{int} o algo a lo que \texttt{int} se castee automáticamente

El vector \texttt{terms} tiene los términos del polinomio con cada monomio con coeficiente distinto de cero apareciendo exactamente una vez y se mantiene siempre ordenado por el orden monomial.

Este struct tiene implementada las operaciones básicas con polinomios incluyendo la suma y el producto, métodos para leer e imprimir polinomios tanto de forma bonita como se los suele escribir como en un formato fácil de leer desde otro código y el orden polinomial correspondiente al orden monomial.

El formato fácil de leer desde código consiste en, primero un número entero no negativo $m$, la cantidad de términos, seguido de la descripción de $m$ términos. La descripción de cada término consiste en primero el coeficiente y después la descripción del monomio. El coeficiente tiene se lee haciendo \texttt{>> c} donde \texttt{c} es una variable de tipo \texttt{K}, así que \texttt{K} tiene que tener \texttt{>>} implementado para que se pueda leer polinomios. Se puede representar así el formato:

\begin{lstlisting}[escapechar=+]
  +$m$+
  +$c_1$+ +$n_1$+ +$x_{1, 1}$+ … +$x_{1, n_1}$+
  ፧
  +$c_m$+ +$n_m$+ +$x_{m, 1}$+ … +$x_{m, n_m}$+
\end{lstlisting} % Los tres puntitos verticales por algún motivo no se muestran ni con ese caracter ni con ⋮


\end{document}
